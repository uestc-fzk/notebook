# 位运算

## 异或

异或：可理解为**无进位相加**，满足**交换律**和**结合律**：`a^b=b^a`、`a^b^c=a^(b^c)`

特殊情况：`0^N=N`、`N^N=0`

案例1：**交换两数之值**

```java
public static void main(String[] args) {
    int a = 5, b = 2;
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
    System.out.println(a);// 2
    System.out.println(b);// 5
}
```

解释：

上面代码对b的操作其实是`b=a^b^b`，根据异或规律可知即`b=a`；而对a的操作为：`a=a^b^a`，所以得`a=b`，从而实现了值交换。

案例2：**取出最右侧位上的1**

```java
int a = 400;
int b = a & (~a + 1);// 即一个数 与 自己取反+1 可以得到最右侧的1
System.out.println(b);
```

练习题：

1、一个int数组arr[]，里面有a和b是出现了奇数次，其余数都是出现偶数次，求出a和b？

```java
public static void main(String[] args) {
    int[] arr = new int[]{1, 1, 2, 2, 3, 4};

    // 根据异或的n^n=0, 0^n=n的特性
    int eor = 0;
    for (int v : arr) {
        eor ^= v;
    }
    // 此时的eor=a^b，且必不为0
    // 找到eor的最右侧的1，这是a和b第一个不相等的数位
    int rightOne = eor & (~eor + 1);// 一个数 与 自己取反+1 =最右侧的1

    // 此时只需要再将数组进行1次选择性异或即可
    int aorb = 0;
    for (int v : arr) {
        if ((v & rightOne) == 1) {// a或b只有一个可以计算异或值
            aorb ^= v;
        }
    }
    // 此时aorb代表a或b

    System.out.printf("a=%d b=%d \n", aorb, eor ^ aorb);
}
```

- 时间复杂度：O(N)
- 空间复杂度：O(1)

# 二分

> **核心技巧：根据arr[mid]<target或arr[mid]<=target可以维护left左边的都是<target或<=target，从而可以得到第一个>=target或>target的索引，此时该索引为left.**

情况1：只需要找target在数组的索引

```java
/**
 * 二分查找目标
 * left左边都是<target
 * right右边都是>target
 * 若没找到，最后一定是left=right+1
 */
public static int binarySearch(int[] arr, int target, int start, int end) {
    if (start > end) return -1;
    int left = start, right = end;
    while (left <= right) {
        int mid = (left + right) >> 1;
        if (arr[mid] < target) left = mid + 1;
        else if (arr[mid] > target) right = mid - 1;
        else return mid;
    }
    return -1;
}
```

情况2：如果要找某个target的在数组的最左边索引或最右边索引。

> 此索引也可计算将target插入数组的最佳位置(即最右边索引+1)

```java
/**
 * 二分查找第1个target
 * left左边都是<target
 * right右边都是>=target
 * <p>
 * 若要查找最后1个target，很明显只要保证left左边都是<=target，right右边都是>target，最后一个target一定是right
 */
public static int binarySearchFirstTarget(int[] arr, int target, int start, int end) {
    if (start > end) return -1;
    int left = start, right = end;
    while (left <= right) {
        int mid = (left + right) >> 1;
        if (arr[mid] < target) left = mid + 1;
        else if (arr[mid] >= target) right = mid - 1;
    }
    // 因为right右边都是>=target的，所有left=right+1就是第一个target
    if (left <= end && arr[left] == target) return left;
    return -1;
}
```

应用1：二分插入排序

```java
public static void binaryInsertSort(int[] arr, int start, int end) {
    if (start >= end) return;
    // i表示以及有序部分
    for (int i = start; i < end; i++) {
        int aj = arr[i + 1];// aj表示待插入元素
        // 1.aj不用插入，直接追加到有序序列末尾即可
        if (aj >= arr[i]) continue;// 这样可以避免二分查找

        // 2.二分查找最佳插入位置
        // 维护了left左边都是<=target，right右边都是>target
        // 那么最佳插入位置是left
        int left = start, right = i;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (arr[mid] <= aj) left = mid + 1;
            else right = mid - 1;
        }

        // 3.此时left就是第一个>aj的索引，也即aj将插入的索引
        if (i + 1 >= left)
            System.arraycopy(arr, left, arr, left + 1, i + 1 - left);
        arr[left] = aj;
    }
}
```

> **总之，二分的技巧就是维护left左边是怎么样的，right右边是怎么样的，然后根据情况来判断是取left还是right，且最后永远是`left=right+1`，同时要处理好可能的left会超过数组边界或right会为-1。**

## 练习题

题1：一个数组int[]，相邻两数不相等，求区域最小值，即其左右相邻数都大于自己，边界则只需满足考虑一边即可？

```java
static int getRegionMin(int[] arr) {
    // 要求arr长度>=2
    if (arr.length == 2) return Math.min(arr[0], arr[1]);
    int len = arr.length;
    // 1.先判断两边
    if (arr[0] < arr[1]) return arr[0];
    if (arr[len - 2] > arr[len - 1]) return arr[len - 1];

    // 2.二分查找区域最小
    int left = 0, right = len - 1;
    while (left <= right) {
        int mid = (left + right) >> 1;
        // 2.1 先判断mid是否满足
        if ((mid == 0 || arr[mid - 1] > arr[mid]) &&
            (mid == len - 1 || arr[mid] < arr[mid + 1]))
            return arr[mid];
        // 2.2 mid比相邻两边的某边大，选小的那边
        else if (mid != 0 && arr[mid] > arr[mid - 1]) right = mid - 1;
        else left = mid + 1;
    }
    throw new RuntimeException(Arrays.toString(arr));// 代码写错了
}
```

# 链表

```java
// 最简单的单链表
public static class ListNode {
    public int val;
    public ListNode next;

    public ListNode(int val) {
        this.val = val;
        this.next = null;
    }

    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

## 翻转链表

翻转链表就是将链表从头结点翻转为以尾结点作为首结点，依次连接

```java
/** 链表翻转
     * 时间复杂度：O(N)
     * 空间复杂度：O(1)
     */
public static ListNode reverse(ListNode head) {
    if (head == null) return null;

    ListNode pre = null, curr = head;
    while (curr != null) {
        ListNode next = curr.next;

        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;
}
```

这个示例是将链表完全翻转，也可以用一个集合来收集所有的结点，再依次相连，不过这样空间复杂度就是O(N)了。

### 部分翻转链表

在一些情况下，并不会去完全翻转整个链表，而是翻转一部分，如每隔k个节点进行一次翻转。如[1,2,3,4,5,6,7]翻转为[3,2,1,6,5,4,7],此处按k=3进行翻转：

```java
/*部分翻转链表，将给定的头结点到尾结点进行翻转
    返回尾结点作为翻转后的头结点，
    且翻转前的头结点需指向为null，以避免翻转成一个环了*/
public static ListNode reverse(ListNode head, ListNode tail) {
    if (head == null||head==tail) return head;

    ListNode pre = null, curr = head;
    while (tail!=pre) {
        ListNode next = curr.next;
        // 指针交换
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;// 翻转前的尾结点，翻转后的头结点
}
```

这里仅仅给出了一个头结点到一个尾结点的翻转，而要作为一个链表中k个节点翻转，还需处理好每个分组的连接处的连接。

### 案例：k个一组链表翻转

力扣25题，字节一面算法题(我寄于此)。

> 描述：
> 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
> k 是一个正整数，它的值小于或等于链表的长度。
> 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group
>

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {

        ListNode firstOfGroup = head, lastOfGroup,
                lastTail = null, result = null;
        while (firstOfGroup != null) {
            lastOfGroup = firstOfGroup;
            int groupLen;// 代表此组长度
            for (groupLen = 1; groupLen < k && lastOfGroup.next != null; groupLen++)
                lastOfGroup = lastOfGroup.next;

            ListNode firstOfNextGroup = lastOfGroup.next;
            // 最后一组，且不为k的话，则不翻转
            if (groupLen < k) {
                if (lastTail == null) result = head;// 说明第一组就不为k了
                else
                    lastTail.next = firstOfGroup;// 衔接上一组

                break;
            }

            ListNode headOfGroup = reversePart(firstOfGroup, lastOfGroup);// 这里翻转的可能是k个，也可能没有k个
            if (lastTail == null) // 说明是第一组
                result = headOfGroup;
            else // 接上上一组
                lastTail.next = headOfGroup;
            lastTail = firstOfGroup;

            firstOfGroup = firstOfNextGroup;
        }

        return result;
    }

    /*部分翻转，返回翻转后的头结点*/
    public ListNode reversePart(ListNode head, ListNode tail) {
        if (head == null) return null;

        ListNode pre = null, curr = head;
        while (tail != pre) {
            ListNode next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }

        return pre;// 翻转前的尾结点，翻转后的头结点
    }
}
```

## 切分链表

仅需要6个变量即可对单链表进行三向切分。

- 思想：维护3个子链表，分别代表小于/等于/大于部分，切分链表将各个结点加入不同子链表，最后合并。

```java
// 将单链表切分为小于pivot的放左边，等于pivot放中间，大于pivot放右边
// 一种简单粗暴的方式是将链表所有结点放入数组，然后对数组进行1次三向切分
// 其实对于链表，更优美的方式是用6个变量即可
static ListNode partition(ListNode root, int pivot) {
    if (root == null || root.next == null) return root;

    ListNode sHead = null, sTail = null;// 小于部分头尾结点
    ListNode mHead = null, mTail = null;// 等于部分头尾结点
    ListNode bHead = null, bTail = null;// 大于部分头尾结点

    // 1.切分
    for (ListNode node = root; node != null; node = node.next) {
        if (node.val < pivot) {
            if (sHead == null) sHead = node;
            if (sTail != null) sTail.next = node;
            sTail = node;
        } else if (node.val == pivot) {
            if (mHead == null) mHead = node;
            if (mTail != null) mTail.next = node;
            mTail = node;
        } else {
            if (bHead == null) bHead = node;
            if (bTail != null) bTail.next = node;
            bTail = node;
        }
    }
    // 2.合并
    if (bTail != null) bTail.next = null;

    if (mTail != null) mTail.next = bHead;
    else mHead = bHead;

    if (sTail != null) sTail.next = mHead;
    else sHead = mHead;

    return sHead;
}
```

## 快慢指针

题目描述：找到某个无环单链表的中间节点。

思路：用快慢指针，快指针走2步，慢指针走1步，快指针到末尾，则慢指针到中间节点。

```java
public ListNode midNode(ListNode head){
    if(head==null||head.next==null) return head;
    // 1.快指针设为head.next的原因是slow走1步为head，fast走两步本来就要该是head.next
    // 若fast=head,slow=head，则两者都是从head开始走，那么head这个点就无法计入链表长度
    ListNode fast=head.next,slow=head;// 快指针和慢指针走1次
    
    // 2.fast走到尾，走(n+1)/2-1次
    while(fast!=null&&fast.next!=null){
        fast=fast.next.next;
        slow=slow.next;
    }
    return slow;// 此时slow必为中间节点
}
```

这种走法走出来的slow指针必为中间节点，链表长度为n，则**快指针和慢指针一共会走(n+1)/2次**，那么**慢指针就恰好在中间节点**。

## 环形链表入口节点

力扣：https://leetcode.cn/problems/c32eOV/

描述：给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 `next` 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 `null`。

```java
public ListNode detectCycle(ListNode head) {
    if(head==null||head.next==null) return null;

    // 1.快慢指针找到相遇点c1
    ListNode fast=head.next,slow=head;
    ListNode c1=null;// 快慢指针相遇点
    while(fast!=null&&fast.next!=null){
        fast=fast.next.next;
        slow=slow.next;
        if(fast==slow) {
            c1=fast;
            break;
        }
    }
    if(c1==null) return null;// 无环
    // 2.从head出发找到入环点
    // 设头结点到入环点长度s，入环点到相遇点长度c1，相遇点到入环点长度c2
    // 快指针走过=s+c1+(c1+c2)*n; n>=1
    // 慢指针走过=s+c1；慢指针必不可能走过超过1圈
    // 则s=n*(c1+c2)-c1，此时若让两个指针分别从head出发和c1出发且步速为1，则必在入口点相遇
    ListNode i=head,j=c1.next;
    while(i!=j){
        i=i.next;
        j=j.next;
    }
    return i;
}
```

解析看注释，这个找入口节点的技巧一定要记住，笔试用不上，面试吹牛p用。

笔试找入口点直接用HashMap做，写的快的多。

# 树

## 二叉查找树

> 二叉搜索树（BST）是二叉树的一种特殊表示形式，它满足如下特性：
>
> 1. 每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值。
>
> 2. 每个节点中的值必须小于（或等于）存储在其右子树中的任何值。

对于二叉搜索树，我们可以通过`中序遍历`得到一个`递增的`有序序列。因此，中序遍历是二叉搜索树中最常用的遍历方法。

### 结点定义

对于二叉树结点的定义如下：

```java
/**
 * @author fzk
 * @date 2021-07-07 18:35
 */
// Definition for a binary tree node.
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode() {
    }

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 中序遍历

中序遍历为：先遍历左孩子，再遍历根结点，再遍历右孩子。递归实现如下：

```java
    /**
     * 中序遍历
     *
     * @param root 传入需要遍历的二叉树
     * @param list 将中序遍历的结果放入此数组中
     */
    private static void inorderTraversal(TreeNode root, List<Integer> list) {
        if (root == null)
            return;
        inorderTraversal(root.left, list);
        list.add(root.val);
        inorderTraversal(root.right, list);
    }
```

前序遍历和后续遍历只需调换那2个递归和add方法之间的顺序即可。

### 迭代器

```java
// Definition for a binary tree node.
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode() {
    }

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }

    public Iterator<TreeNode> iterator() {
        return new BSTIterator(this);
    }

    final class BSTIterator implements Iterator<TreeNode> {
        private final LinkedList<TreeNode> nodeList;// 双向链表模拟栈

        public BSTIterator(TreeNode root) {
            nodeList = new LinkedList<>();
            dfsLeft(root);
        }

        @Override
        public boolean hasNext() {
            return nodeList.size() > 0;
        }

        @Override
        public TreeNode next() {
            TreeNode root = nodeList.removeFirst();
            dfsLeft(root.right);
            return root;
        }

        void dfsLeft(TreeNode root) {
            while (root != null) {
                nodeList.addFirst(root);
                root = root.left;
            }
        }
    }
}
```

> 思想：
> 采用中序遍历的迭代器，只实现了next和hasnext方法
> 迭代器使用O(h)的内存，h为树的高度
>
> 1. 先将当前节点的所有左孩子及其左孩子压入栈，压到没有为止；
> 2. 将最后一个压入的节点弹出（栈顶元素），作为next()的返回值；
> 3. 将当前弹出节点的右节点作为当前节点，重复步骤1
>
> 这种方法的实现比较节省空间，而使用双向链表方便了快速的插入和移除栈顶元素。

### 删除结点

> 二叉搜索树的3个基本操作：查询、插入和删除。
> 查询操作非常简单；
> 插入可以很简单，也可以很复杂，如平衡二叉树。
> 删除操作就比较复杂了。

删除操作比较复杂，有很多删除的方法，这里给出整体变化最小的一种方法：

> 选择一个合适的后继结点或前驱结点来**替代**被删除结点。

根据被删除结点的情况，分为以下3类：

1. 如果目标节点**没有子节点**，我们可以直接移除该目标节点。
2. 如果目标节**只有一个子节点**，我们可以用其子节点作为替换。
3. 如果目标节点**有两个子节点**，我们需要用其中序**后继节点**或者**前驱节点**来替换，再删除该目标节点。

![bst_deletion_case_1](数据结构.assets/bst_deletion_case_1.png)

![bst_deletion_case_2](数据结构.assets/bst_deletion_case_2.png)

![bst_deletion_case_3](数据结构.assets/bst_deletion_case_3.png)

```java
   public TreeNode deleteNode(TreeNode root, int key) {
        TreeNode p=root,parent=null;// parent为被删结点的父节点
        boolean flag=true;// true代表被删除结点是parent的左孩子，false代表右孩子
        if(p==null)
            return null;
        if(p.val==key){
            if(p.left!=null){
                TreeNode pre_node=getPreNode(p.left);
                pre_node.right=p.right;
                return pre_node;
            }
            return p.right;
        }
        while(p!=null){
            if(key<p.val){
                parent=p;
                p=p.left;
                flag=true;
            }
            else if(key>p.val){
                parent=p;
                p=p.right;
                flag=false;
            }
            else{
                if(p.left==null&&p.right==null){// 第1种情况：没有子结点
                    if(flag){
                        parent.left=null;
                        return root;
                    }
                    parent.right=null;
                    return root;
                }else if(p.left==null){// 第2.1种情况：没有左孩子，有右孩子
                    if(flag){
                        parent.left=p.right;
                        return root;
                    }
                    parent.right=p.right;
                    return root;
                }
                else if(p.right==null){// 第2.2中情况：有左结点，没有右结点
                    if(flag){
                        parent.left=p.left;
                        return root;
                    }
                    parent.right=p.left;
                    return root;
                }else{
                    // 第3中情况：左右结点都有
                    // 找到其前驱结点
                    TreeNode pre_node = getPreNode(p.left);
                    pre_node.right=p.right;
                    if(flag){
                        parent.left=pre_node;
                        return root;
                    }
                    parent.right=pre_node;
                    return root;
                }
            }
        }
        return root;
    }
    public TreeNode getPreNode(TreeNode root){
        TreeNode p=root;
        if(root==null||root.right==null)
            return root;
        TreeNode parent=null;
        // 找前继结点
        while(root.right!=null){
            parent=root;
            root=root.right;
        }
        parent.right=root.left;
        root.left=p;
        return root;
    }
```

## 平衡二叉查找树

运行时间都是**对数级别**，**树高为~lgN**.需要保持二分查找树的**平衡性**。

但是，动态插入中保证树的完美平衡**代价太高**了。

**为什么需要用到高度平衡的二叉搜索树?**

> 我们已经介绍过了二叉树及其相关操作, 包括搜索、插入、删除。当分析这些操作的时间复杂度时，我们需要注意的是树的高度是十分重要的考量因素。以搜索操作为例，如果二叉搜索树的高度为 h ，则时间复杂度为 O(h) 。二叉搜索树的高度的确很重要。

> 所以，我们来讨论一下树的节点总数 N 和高度 h 之间的关系。
> 对于一个平衡二叉搜索树, h=lgN，
> 但一个普通的二叉搜索树，在最坏的情况下，它可以退化成一个链。

> 因此，具有 N 个节点的二叉搜索树的高度在 logN 到 N 区间变化。
> 也就是说，搜索操作的时间复杂度可以从 logN 变化到 N 。这是一个巨大的性能差异。

> 所以说，高度平衡的二叉搜索树对提高性能起着重要作用。

**如何实现一个高度平衡的二叉搜索树?**
有许多不同的方法可以实现。尽管这些实现方法的细节有所不同，但他们有相同的目标:

> 采用的数据结构应该满足二分查找属性和高度平衡属性。
> 采用的数据结构应该支持二叉搜索树的基本操作，包括在 **O(logN)** 时间内的搜索、插入和删除，即使在最坏的情况下也是如此。
> 常见的的高度平衡二叉树：
>
> - 红黑树
> - AVL树
> - 伸展树
> -  树堆

**高度平衡的二叉搜索树的实际应用**
高度平衡的二叉搜索树在实际中被广泛使用，因为它可以在 *O(logN)* 时间复杂度内执行所有搜索、插入和删除操作。

> 平衡二叉搜索树的概念经常运用在 Set 和 Map 中。Set 和 Map 的原理相似。

> 通常，有两种最广泛使用的集合：散列集合（**HashSet**）和 树集合（**TreeSet**）。
>
> 树集合，Java 中的 Treeset 或者 C++ 中的 set ，是由高度平衡的二叉搜索树实现的。
> 因此，搜索、插入和删除的时间复杂度都是O(logN)。
>
> 散列集合，Java 中的 HashSet 或者 C++ 中的 unordered_set ，是由哈希实现的，但是平衡二叉搜索树也起到了至关重要的作用。当存在具有相同哈希键的元素过多时，将花费 O(N) 时间复杂度来查找特定元素，其中N是具有相同哈希键的元素的数量。 通常情况下，使用高度平衡的二叉搜索树将把**时间复杂度从 O(N) 改善到 O(logN)** 。

哈希集和树集之间的本质区别在于树集中的键是有序的。



### AVL树

- 自平衡二叉查找树，又称高度平衡树。

什么是一个高度平衡的二叉搜索树?

> 树结构中的常见用语:
>
> 1. 节点的**深度** - 从树的根节点到该节点的边数
>
> 2. 节点的**高度** - 该节点和叶子之间最长路径上的边数
>
> 3. 树的高度 - 其根节点的高度

一个高度平衡的二叉搜索树（*平衡二叉搜索树*）是在插入和删除任何节点之后，可以自动保持其高度最小。也就是说，有 N 个节点的平衡二叉搜索树，它的高度是 *logN* 。并且，***每个节点的两个子树的高度不会相差超过 1***。

>为什么是 `logN` 呢?
>- 一个高度为 `h` 的二叉树 
>  2^0^ + 2^1^ +...+ 2^h-1^ +1 <= N <=2^0^ + 2^1^ +...+ 2^h^
>- 换言之，一个有 `N` 个节点，且高度为 `h` 的二叉树
    2^h^ <= N <=2^h+1^ -1.
>    h <= lgN < h+1
  - 所以： 
    h = floor(log~2~N).

#### 判断AVL

```java
class Solution {
    private boolean isBalanced;
    public boolean isBalanced(TreeNode root) {
        /*
        采用后续遍历的方式，进行每一层的高度判断
         */
        isBalanced=true;
        getHigh(root);
        return isBalanced;
    }

    public int getHigh(TreeNode root) {
        if (root == null)
            return 0;
        if (!isBalanced)
            return 0;

        int high_left = getHigh(root.left);
        int high_right = getHigh(root.right);
        if (Math.abs(high_left - high_right) > 1) {
            isBalanced = Boolean.FALSE;
        }
        return Math.max(high_left, high_right) + 1;
    }
}
```

> 判断的核心在于判断左结点和右结点的高度是否相差大于1，那么采用后续遍历递归的方式即可解决。
> 但是内存递归内存消耗较多。

#### 构建AVL

给你一个整数数组 nums ，其中元素已经按 **升序** 排列，将其转换为一棵 高度平衡 二叉搜索树。

```java
    /**
     * 传入一个数组，将其构成AVL树
     *
     * @param nums 按 严格递增 顺序排列
     * @return
     */
    public TreeNode sortedArrayToBST(int[] nums) {
        /*
        采用二分思想，左边构成左子树，右边的构成右子树，中间构成根结点
         */
        return sortedArrayToBST(nums, 0, nums.length - 1);
    }

    public TreeNode sortedArrayToBST(int[] nums, int low, int high) {
        if (low > high)
            return null;

        int mid = (low + high) >>> 1;
        TreeNode node = new TreeNode(nums[mid], null, null);//构建根结点
        node.left = sortedArrayToBST(nums, low, mid - 1);//构建左子树
        node.right = sortedArrayToBST(nums, mid + 1, high);//构建右子树
        return node;
    }
```

### 2-3查找树

为了保证查找树的平衡性，设置树中的一个结点保存多个键。
将标准二叉树的结点称为[^2-结点],而[^3-结点].

> - 2-结点，一个键，两条链接，
>   左链接指向的2-3树的键都小于该结点，
>   右链接指向的2-3树中的结点的键都大于该结点。
> - 3-结点，2个键，3条链接，
>   左链接都小于该节点，
>   中链接指向的2-3树的键都位于该结点两个键之间；
>   右链接都大于该结点。

## B+树

资料：https://segmentfault.com/a/1190000041696709

B+树BTree.java：

```java
/**
 * 自定义实现B+树
 * B树中所有结点的孩子个数的最大值称为B树的阶, 一般从查找效率考虑，通常要求M>=3
 * 每一个节点最多M个子节点，子节点与key数量相同
 * key是唯一，即唯一性索引
 * <a href="https://segmentfault.com/a/1190000041696709">B+树原理以及Go语言实现</a>
 * 注意：该文章的理论可借鉴，实现有问题
 *
 * @author fzk
 * @datetime 2023-01-14 23:25:41
 */
public class BTree {
    // B+树的阶
    public final int M;
    private final ReadWriteLock lock = new ReentrantReadWriteLock();// 读写锁
    private BNode root;// 根结点
    private LeafNode head;// 叶子结点链表头结点

    public BTree(int m) {
        if (m < 4) throw new RuntimeException("B+树的阶不能小于4");
        M = m;
    }

    /**
     * 插入或更新指定key的值
     *
     * @return 若key不存在则null，存在则返回旧值
     */
    public synchronized Object put(String key, Object value) {
        lock.writeLock().lock();
        try {
            // 根结点为空，说明的第一次插入，需更新root和head
            if (root == null) {
                assert head == null : "root为null但head不为null";
                root = new LeafNode(M);
                root.insert(key, value);
                head = (LeafNode) root;
                return null;
            }

            // 如果root是叶子结点，直接插入
            if (root instanceof LeafNode) {
                assert root == head && root.parentNode == null : "root是叶子结点却不等于head或其父节点不为null";
                return insertNode(root, key, value);
            }

            // 从root开始找到key应该插入的叶子结点
            LeafNode toInsertLeaf = findLeafNodeByKey(root, key);
            return insertNode(toInsertLeaf, key, value);
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * 返回指定key的值
     *
     * @return null或值
     */
    public synchronized Object get(String key) {
        lock.readLock().lock();
        try {
            if (root == null || key.compareTo(root.getMinKey()) < 0) return null;
            LeafNode leafNode = findLeafNodeByKey(root, key);
            BNode.SearchKeyResult keyResult = leafNode.searchKeyIndex(key);
            if (keyResult.exists) {
                return leafNode.entries[keyResult.index].value;
            }
            return null;
        } finally {
            lock.readLock().unlock();
        }
    }

    /**
     * 删除指定key
     *
     * @return key不存在返回null，存在时返回删除的旧值
     */
    public synchronized Object remove(String key) {
        lock.writeLock().lock();
        try {
            if (root == null || key.compareTo(root.getMinKey()) < 0) return null;
            LeafNode node = findLeafNodeByKey(root, key);
            return deleteKeyFromNode(node, key);
        } finally {
            lock.writeLock().unlock();
        }
    }

    // 删除节点上的key映射
    private Object deleteKeyFromNode(BNode node, String key) {
        // 1.查找key在node的索引
        BNode.SearchKeyResult keyResult = node.searchKeyIndex(key);
        if (!keyResult.exists) return null;
        int index = keyResult.index;
        Object result = node.entries[keyResult.index].value;
        // 2.key为此结点min key，且删除后结点为空，把结点也删了
        if (index == 0 && node.size == 1) {
            // 2.1 如果该节点是root，则直接清空b+树
            if (node == root) {
                clear();
                return result;
            }
            // 2.2 维护双向链表
            BNode pre = node.preNode, next = node.nextNode;
            if (pre != null) pre.nextNode = next;
            if (next != null) next.preNode = pre;
            if (head == node) head = (LeafNode) next;// 如果是删除头结点，修改为后继节点

            // 2.3 从父节点中删除指向此节点的key
            BNode parent = node.parentNode;
            node.clear();// 清空node避免内存泄露
            deleteKeyFromNode(parent, key);
            return result;
        }

        // 3.从结点删除key
        System.arraycopy(node.entries, index + 1, node.entries, index, node.size - index - 1);
        node.entries[--node.size] = null;// 置空避免内存泄漏

        // 4.key为此节点min key，需要循环修改祖先结点指向此节点的key
        if (index == 0) {
            String newMinKey = node.getMinKey();
            node.dfsUpdateMinKey(newMinKey, key);
        }

        // 4.node的子结点或元素数量减少，尝试合并node
        tryMergeNode(node);
        return true;
    }

    /**
     * 叶子结点需要合并的情况：
     * |509 906|
     * |509|  |906|
     * |509|  |906|
     * |509|  |906|
     * 索引结点需要合并的情况：
     * |427 944|
     * |427|  |944|
     * |427|  |944|
     * |427 509 625 906|  |944 945 946|
     * 合并索引结点：尽量向左合并，这样可以减少min key修改
     * 目的在于降低层高，每个索引结点仅持有少量的子结点时，可能出现叶子结点非常少的情况下，层高非常高
     * 是索引结点说明其某个子结点刚被删除
     *
     * @param node 叶子结点和旁边的合并，索引结点怎么合并呢？
     */
    private void tryMergeNode(BNode node) {
        if (node.size >= this.M / 2) return;
        BNode pre = node.preNode, next = node.nextNode;
        if (pre != null && (pre.size + node.size) <= M) {
            // 优先将node合入左节点
            doMergeNode(pre, node);
        } else if (next != null && (next.size + node.size) <= M) {
            // 再考虑将右节点合入node
            doMergeNode(node, next);
        } else if (pre == null && next == null) {
            // 没有兄弟节点，必须是root节点
            assert root == node : "没有兄弟节点必须的root节点";
            // 如果root节点页key数量为1，是索引页时，则循环向下降低层高，即删除没必要的索引页
            while (root.size == 1 && root instanceof IndexNode) {
                BNode child = (BNode) root.entries[0].value;
                child.parentNode = null;// root节点没有父节点
                root.clear();// 清空旧root节点
                root = child;
            }
        }
    }

    // 将right节点合入left节点，尽量都向左合并，这样可以不修改Head结点
    private void doMergeNode(BNode left, BNode right) {
        // 1.将right节点拷贝到left节点
        System.arraycopy(right.entries, 0, left.entries, left.size, right.size);
        left.size += right.size;
        // 如果是索引节点需要维护父子关系
        if (left instanceof IndexNode) {
            for (int i = 0; i < right.size; i++) {
                ((BNode) right.entries[i].value).parentNode = left;
            }
        }

        // 2.维护双向链表
        BNode next = right.nextNode;
        left.nextNode = next;
        if (next != null) next.preNode = left;

        // 3.删除节点
        deleteKeyFromNode(right.parentNode, right.getMinKey());
        right.clear();// 清空节点避免内存泄露
    }

    private Object insertNode(BNode node, String key, Object value) {
        // key存在，则覆盖
        if (node.isExists(key)) {
            // 如果已经存在，则覆盖原值，此时这里必须是叶子结点
            assert (node instanceof LeafNode) : String.format("即将发生key:%s 替换的结点居然不是叶子结点?", key);
            return node.update(key, value);
        }

        // 新key，则插入
        BNode toInsert = node;
        if (node.isFull()) {// mmp，页分裂，向右分裂一半
            // todo: 这里需要根据即将插入的key来进行更优化的页分裂
            BNode rightNode = splitNode(node);

            // 页分裂完成，选择插入结点
            if (key.compareTo(rightNode.getMinKey()) >= 0) {
                toInsert = rightNode;
            }
        }
        // 此时结点必然未满，直接插入
        toInsert.insert(key, value);
        return null;
    }

    // 结点向右分裂
    private BNode splitNode(BNode leftNode) {
        BNode rightNode;
        if (leftNode instanceof LeafNode) rightNode = new LeafNode(M);
        else rightNode = new IndexNode(M);

        // 将一半key拷贝到新结点
        int partitionIndex = leftNode.size >> 1;
        System.arraycopy(leftNode.entries, partitionIndex, rightNode.entries, 0, leftNode.size - partitionIndex);
        Arrays.fill(leftNode.entries, partitionIndex, leftNode.size, null);// 必须置null避免内存泄漏(删除key这里却有引用)
        // 更新2个节点的size
        rightNode.size = leftNode.size - partitionIndex;
        leftNode.size = partitionIndex;

        // 维护双向链表
        BNode next = leftNode.nextNode;
        leftNode.nextNode = rightNode;
        rightNode.preNode = leftNode;
        rightNode.nextNode = next;
        if (next != null) {
            next.preNode = rightNode;
        }

        // 索引结点需维护子结点的父节点
        if (leftNode instanceof IndexNode) {
            for (int i = 0; i < rightNode.size; i++) {
                BNode childNode = (BNode) rightNode.entries[i].value;
                childNode.parentNode = rightNode;
            }
        }

        // 将新结点插入其父节点中
        if (leftNode.parentNode == null) {
            // 说明此时node为root
            assert leftNode == root : "node的父节点为null却不是root";

            // 必须新建父节点作为root
            IndexNode parent = new IndexNode(M);
            // 父节点维护子结点
            // 将node和rightNode作为子结点插入到新建父节点中
            parent.insert(leftNode.getMinKey(), leftNode);
            parent.insert(rightNode.getMinKey(), rightNode);
            root = parent;
        } else insertNode(leftNode.parentNode, rightNode.getMinKey(), rightNode);
        return rightNode;
    }

    // 找到key所在或即将插入的叶子结点
    private LeafNode findLeafNodeByKey(BNode from, String key) {
        if (from instanceof LeafNode ln) return ln;

        BNode cur = from;
        while (cur instanceof IndexNode) {
            // k1 <= key < k2，则k1指向的子结点为正确路径的下一层级
            BNode.SearchKeyResult keyResult = cur.searchKeyIndex(key);
            int nextIndex;
            if (keyResult.exists) {
                nextIndex = keyResult.index;
            } else if (keyResult.index == 0) {
                nextIndex = 0;
            } else {
                // 不存在时，返回的是key应该插入的索引，则下个节点索引为index-1
                nextIndex = keyResult.index - 1;
            }
            BNode next = (BNode) cur.entries[nextIndex].value;
            // 如果指向的是叶子结点，直接返回key所在叶子结点
            if (next instanceof LeafNode leaf) {
                return leaf;
            }
            cur = next;
        }
        throw new RuntimeException(String.format("%s 没找到叶子结点", key));
    }

    public void printTree() {
        if (root == null) System.out.println("{}");
        else root.printSelf();
    }

    // 打印叶子结点双向链表
    public String getLeafString() {
        if (head == null) return "{}";
        // 先打印
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        BNode cur = head;
        while (cur != null) {
            sb.append(cur.getKeysString()).append(", ");
            cur = cur.nextNode;
        }
        sb.delete(sb.length() - 2, sb.length());
        sb.append('}');
        return sb.toString();
    }

    public void clear() {
        this.root = null;
        this.head = null;
    }

    // 非叶子结点，即索引结点
    static class IndexNode extends BNode {
        public IndexNode(int m) {
            this.entries = new BEntry[m];
        }
    }


    // 叶子结点
    static class LeafNode extends BNode {
        public LeafNode(int m) {
            this.entries = new BEntry[m];
        }
    }

    // 检查B+树结构是否正常，此操作会以bfs遍历整个树结构，操作代价高
    public void checkTree() {
        if (root == null) return;
        Queue<BNode> queue = new LinkedList<>();
        queue.add(root);
        while (queue.size() > 0) {
            BNode curLevelNode = queue.peek();// 此层当前遍历的节点，用于检查双向链表
            int len = queue.size();// 此层个数
            while (len-- > 0) {
                BNode remove = queue.remove();
                // 1.节点自检
                remove.checkSelf();
                // 2.索引结点：检查父子关系
                // 2.1 检查此节点的key指向的是子结点min key
                // 2.2 检查此节点和子结点的父子关系是否正常
                if (remove instanceof IndexNode ir) {
                    for (int i = 0; i < ir.size; i++) {
                        queue.add((BNode) ir.entries[i].value);
                        if (!ir.entries[i].key.equals(((BNode) ir.entries[i].value).getMinKey())) {
                            throw new RuntimeException(String.format("%s不是其指向的子结点min key", ir.entries[i].key));
                        }
                        if ((((BNode) ir.entries[i].value).parentNode != ir)) {
                            throw new RuntimeException(String.format("%s的父节点指向错误", ir.entries[i].key));
                        }
                    }
                }

                // 3.检查双向链表是否正常
                // 首先检查双向链表指向的节点顺序和索引树指向的节点顺序一致
                if (remove != curLevelNode) {
                    printTree();
                    throw new RuntimeException(String.format("min key 为%s的结点顺序不正常", remove.getMinKey()));
                }
                // 检查前后节点指向正确
                if (remove.nextNode != null && remove.nextNode.preNode != remove) {
                    printTree();
                    throw new RuntimeException(String.format("min key为%s的结点后继结点的前继居然不是自己?", remove.getMinKey()));
                }
                // 此节点maxKey<后继节点的minKey
                if (remove.nextNode != null && remove.getMaxKey().compareTo(remove.nextNode.getMinKey()) >= 0) {
                    System.err.printf("此节点： %s，后继节点: %s\n", remove.getKeysString(), remove.nextNode.getKeysString());
                    throw new RuntimeException("此节点maxKey>=后继节点的minKey");
                }
                curLevelNode = curLevelNode.nextNode;
            }
        }
        // 检查head是否指向正确
        if (!head.getMinKey().equals(root.getMinKey()) || head.preNode != null) {
            throw new RuntimeException("head节点错误");
        }
    }
}
```

B树结点BNode.java：

```java
/**
 * B+树结点接口
 *
 * @author fzk
 * @datetime 2023-01-14 23:53:45
 */
public abstract class BNode {
    public int size = 0;// key的数量
    private static final int BinarySearchThreshold = 8;// 二分查找阈值，数组较小时遍历平均情况下会比较次数更少
    public BEntry[] entries;
    public BNode parentNode;
    /**
     * 理论上来说，B+树只有叶子节点需要维护双向链表
     * 这里索引节点也维护双向链表，目的：便于节点合并时寻找兄弟节点
     */
    public BNode preNode;
    public BNode nextNode;

    public String getMinKey() {
        return entries[0].key;
    }

    public String getMaxKey() {
        return entries[size - 1].key;
    }

    public boolean isFull() {
        return size == entries.length;
    }

    public boolean isExists(String key) {
        return searchKeyIndex(key).exists;
    }

    // 查找key的索引，不存在返回-1
    public SearchKeyResult searchKeyIndex(String key) {
        if (size <= 0) return new SearchKeyResult(false, 0);
        if (size >= BinarySearchThreshold) {
            int left = 0, right = size - 1;
            while (left <= right) {
                int mid = (left + right) >> 1;
                int cmp = key.compareTo(entries[mid].key);
                if (cmp < 0) right = mid - 1;
                else if (cmp == 0) return new SearchKeyResult(true, mid);
                else left = mid + 1;
            }
            return new SearchKeyResult(false, left);
        } else {
            // 遍历
            for (int i = 0; i < size; i++) {
                int cmp = key.compareTo(entries[i].key);
                if (cmp == 0) {
                    return new SearchKeyResult(true, i);
                } else if (cmp < 0) {
                    return new SearchKeyResult(false, i);
                }
            }
            return new SearchKeyResult(false, size);
        }
    }

    // 更新key的value，必须已经存在
    public Object update(String key, Object newVal) {
        SearchKeyResult keyResult = searchKeyIndex(key);
        if (!keyResult.exists)
            throw new RuntimeException(String.format("更新key: %s的value时在待替换结点中未找到该key", key));
        Object old = entries[keyResult.index].value;
        entries[keyResult.index].value = newVal;
        // 如果插入的value是结点，则必须维护父子结点关系
        if (newVal instanceof BNode vn) {
            vn.parentNode = this;
        }
        return old;
    }

    /**
     * node结点minKey发生变化时，循环修改node结点的祖先节点的key
     *
     * @param newMinKey 变后的min key
     * @param oldMinKey 变前的min key
     */
    void dfsUpdateMinKey(String newMinKey, String oldMinKey) {
        BNode p = this.parentNode;
        while (p != null) {
            SearchKeyResult keyResult = p.searchKeyIndex(oldMinKey);
            assert keyResult.exists : String.format("min key为%s的结点的父节点中没找到该key", oldMinKey);

            p.entries[keyResult.index].key = newMinKey;
            // 在父节点中也是min key，循环向上修改
            if (keyResult.index == 0) p = p.parentNode;
            else break;// 父节点中不是minKey，修改到此结束
        }
    }

    // 插入key
    public void insert(String key, Object value) {
        // 如果插入key比当前结点minKey都小，则需要循环维护指向此节点的父节点的key（指向此节点的key必须是结点最小key）
        if (this.size > 0 && key.compareTo(getMinKey()) < 0 && this.parentNode != null) {
            dfsUpdateMinKey(key, getMinKey());
        }

        // 插入排序咯
        int i = size;// 待插入索引
        while (i > 0 && key.compareTo(entries[i - 1].key) < 0) {
            entries[i] = entries[i - 1];
            i--;
        }
        entries[i] = new BEntry(key, value);
        size++;
        // 如果插入的value是结点，则必须维护父子结点关系
        if (value instanceof BNode vn) {
            vn.parentNode = this;
        }
    }

    public String getKeysString() {
        if (size == 0) return "{}";
        StringBuilder sb = new StringBuilder();
        sb.append('{');
        for (int i = 0; i < size; i++) {
            sb.append(entries[i].key).append(", ");
        }
        sb.delete(sb.length() - 2, sb.length());
        sb.append('}');
        return sb.toString();
    }

    public void clear() {
        size = 0;
        entries = null;// 置空避免内存泄露
        parentNode = null;
        preNode = null;
        nextNode = null;
    }

    // 每个结点维护一组键值映射
    public static class BEntry {
        public String key;
        public Object value;// 在叶子结点中为保存的值，在非叶子结点中保存为该key指向的childNode

        public BEntry(String key, Object value) {
            this.key = key;
            this.value = value;
        }
    }

    public static class SearchKeyResult {
        public boolean exists;// key是否存在
        public int index;// key存在时的索引，或不存在时应该插入的位置

        public SearchKeyResult(boolean exists, int index) {
            this.exists = exists;
            this.index = index;
        }
    }

    public void checkSelf() {
        if (this.size == 0) return;
        // 1.先检查size正确
        for (int i = 0; i < size; i++) {
            if (entries[i] == null) {
                throw new RuntimeException("必须不为null, index: " + i);
            }
        }
        for (int i = size; i < entries.length; i++) {
            if (entries[i] != null) {
                throw new RuntimeException(String.format("index: %d --> %s 必须为null, %s", i, entries[i].key, getKeysString()));
            }
        }
        // 2.检查key顺序正确
        for (int i = 1; i < size; i++) {
            if (entries[i - 1].key.compareTo(entries[i].key) >= 0) {
                throw new RuntimeException(String.format("index: %d的key>=其后的key, %s", i - 1, getKeysString()));
            }
        }
        // 3.没有兄弟节点时，肯定没有父节点
        if (preNode == null && nextNode == null && parentNode != null) {
            throw new RuntimeException("没有兄弟节点时，父节点必须为null");
        }
    }

    // 打印B+树
    public void printSelf() {
        Queue<BNode> queue = new LinkedList<>();
        queue.add(this);
        while (queue.size() > 0) {
            // 这一层个数
            int len = queue.size();
            while (len-- > 0) {
                BNode remove = queue.remove();
                System.out.print(" |");
                for (int i = 0; i < remove.size; i++) {
                    if (i == remove.size - 1)
                        System.out.printf("%s", remove.entries[i].key);
                    else System.out.printf("%s ", remove.entries[i].key);
                    if (remove.entries[i].value instanceof BNode) {
                        queue.add((BNode) remove.entries[i].value);
                    }
                }
                System.out.print("| ");
            }
            System.out.println();
        }
    }
}
```

测试代码：

```java
/**
 * @author fzk
 * @datetime 2023-01-16 00:13:01
 */
public class BTest {
    public static void main(String[] args) {
        BTest t = new BTest();
        for (int i = 0; i < 100; i++) {
            t.test1();
        }
        t.test3();
    }

    // 测试字符串随机插入和随机删除
    void test1() {
        BTree b = new BTree(16);
        ArrayList<String> list = new ArrayList<>();
        HashSet<String> set = new HashSet<>();
        try {
            for (int i = 0; i < 1000; i++) {
                String key = MyRandomUtil.randomLowerStr(4);
                list.add(key);
                if (!set.add(key)) {
                    System.out.println("重复key: " + key);
                }
                b.put(key, i);
                b.checkTree();
            }

            b.printTree();
            System.out.println(set.size());

            set.forEach(k -> {
                if (b.remove(k) == null) {
                    throw new RuntimeException(String.format("%s删除失败", k));
                }
                b.checkTree();
            });
        } catch (Exception e) {
            System.out.println("插入顺序: " + list);
        }
    }

    void test3() {
        BTree b = new BTree(4);
        String msg = "180, 733, 406, 459, 408, 077, 404, 699, 427, 499, " +
                "433, 999, 484, 647, 920, 057, 482, 859, 357, 802, 724, " +
                "132, 848, 062, 841, 993, 645, 968, 168, 965, 378, 490, " +
                "480, 352, 509, 684, 844, 851, 321, 830, 034, 646, 446, " +
                "233, 842, 005, 373, 906, 525, 266, 838, 558, 696, 246, " +
                "897, 641, 944, 365, 137, 671, 918, 161, 848, 020, 866, " +
                "114, 470, 065, 603, 595, 946, 436, 387, 415, 532, 525, " +
                "303, 261, 676, 040, 873, 745, 678, 185, 303, 784, 297, " +
                "945, 221, 113, 493, 844, 003, 625, 196, 112, 270, 013, 531, 996";
        String[] splits = msg.split(",\\s+");
        HashSet<String> set = new HashSet<>();
        for (String key : splits) {
            if (!set.add(key)) {
                System.out.println("重复key: " + key);
            }
            System.out.println("插入key:" + key);
            b.put(key, 0);
            b.checkTree();
        }

        b.checkTree();
        b.printTree();
        System.out.println("叶子节点: " + b.getLeafString());
        for (String key : set) {
            System.out.println("删除" + key);
            if (b.remove(key) == null) {
                System.out.println("删除失败：" + key);
            }
            b.printTree();
            System.out.println("叶子节点: " + b.getLeafString());
            b.checkTree();
        }
    }
}
```

## 二叉树技巧

```java
// 最简单的二叉树
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 二叉树序列化和反序列化

这里是按照力扣的二叉树表示方式进行序列化和反序列化，序列化和反序列化都是按照广度优先方式进行。

```java
static class Codec {
    /*leetcode 用的是广度优先方式*/
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) return "[]";

        StringBuilder builder = new StringBuilder();
        builder.append("[");

        Queue<TreeNode> queue = new LinkedList<>();
        // 保证队列中不存在null
        queue.offer(root);
        while (queue.size() != 0) {
            TreeNode poll = queue.poll();
            if (poll != nullTreeNode) {
                builder.append(poll.val).append(",");
                queue.offer(poll.left == null ? nullTreeNode : poll.left);
                queue.offer(poll.right == null ? nullTreeNode : poll.right);
            } else builder.append("null,");
        }
        builder.deleteCharAt(builder.length() - 1);// 删掉最后的','
        builder.append("]");

        String s = builder.substring(1, builder.length() - 1);// 准备删除末尾的null
        String[] nodes = s.split(",");
        int tailNullCount = 0;// 末尾的null的数量
        for (int i = nodes.length - 1; i > -1; i--) {
            if ("null".equals(nodes[i])) tailNullCount++;
            else break;
        }

        return builder.delete(builder.length() - 1 - 5 * tailNullCount, builder.length() - 1)
            .toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data.equals("[]")) return null;

        data = data.substring(1, data.length() - 1);
        String[] nodes = data.split(",");
        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));
        queue.offer(root);
        int index = 1;
        while (queue.size() != 0 && index < nodes.length) {
            TreeNode poll = queue.poll();
            // 左子树处理
            if (!"null".equals(nodes[index++])) {
                poll.left = new TreeNode(Integer.parseInt(nodes[index - 1]));
                queue.offer(poll.left);
            }
            // 右子树处理
            if (index >= nodes.length) break;// 先判断是否会越界
            if (!"null".equals(nodes[index++])) {
                poll.right = new TreeNode(Integer.parseInt(nodes[index - 1]));
                queue.offer(poll.right);
            }
        }
        return root;
    }

    /** 表示空树，来保证队列中不存在null */
    private static final TreeNode nullTreeNode = new TreeNode(-1);
}
```

### dfs

深度优先依赖于递归的实现，而递归又隐式依赖于栈。

```java
LinkedList<TreeNode> list = new LinkedList<>();
// 深度优先 先序遍历
public void dfs(TreeNode root) {
    if (root != null) {
        list.add(root);
        dfs(root.left);
        dfs(root.right);
    }
}
```

下面这个示例为依赖于栈实现深度优先遍历：

```java
private LinkedList<TreeNode> list = new LinkedList<>();// 存放遍历结果
private LinkedList<TreeNode> stack = new LinkedList<>();//模拟操作数栈

// 用栈实现的深度优先 先序遍历
public void dfsByStack(TreeNode root) {
    if (root != null) {
        stack.push(root);// 入栈

        while (stack.size() != 0) {
            TreeNode pop = stack.pop();// 出栈
            list.addLast(pop);
            // 这里要做到先序遍历的话，需要先入栈右子树，再入栈左子树，这样才能先遍历左子树
            if (pop.right != null) stack.push(pop.right);
            if (pop.left != null) stack.push(pop.left);
        }
    }
}
```

### bfs实现层序遍历

广度优先遍历就不能依赖递归实现了，而要借助于队列。

```java
private LinkedList<TreeNode> list = new LinkedList<>();// 存放遍历结果

// 广度优先遍历 实现的层序遍历
public void bfs(TreeNode root) {
    if (root != null) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (queue.size() != 0) {
            int num = queue.size();// 这里比较巧妙的是此时的队列长度恰好是二叉树这一层的结点数量
            while (num-- > 0) {
                TreeNode poll = queue.poll();
                list.add(poll);
                if (poll.left != null) queue.offer(poll.left);
                if (poll.right != null) queue.offer(poll.right);
            }
        }
    }
}
```

### BST后继结点

力扣285，给定一棵二叉搜索树和其中的一个节点 `p` ，找到该节点在树中的中序后继。如果没有找到结点或者节点没有中序后继，请返回 `null` 

思路：二叉搜索树按中序遍历将是有序的，后继结点即大于其的第一个结点。按照中序遍历顺序，结点将会按照升序访问，那么在访问到p之后，下一个必定是访问其后继结点。

```java
class Solution {
    private boolean isFound = false;
    private TreeNode midOrderNext = null;

    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        if (root == null) return null;

        dfs(root, p);
        return midOrderNext;
    }

    private void dfs(TreeNode root, TreeNode p) {
        if (root == null) return;
        if (isFound&&midOrderNext!=null) return;//已经找到则不再深入遍历

        dfs(root.left, p);// 遍历左子树
        if (isFound && midOrderNext == null) midOrderNext = root;

        if (root.val == p.val) isFound = true;
        dfs(root.right, p);// 遍历右子树
    }
}
```

### 判断BST

判断某个二叉树是否为二叉查找树BST？

```java
// 思路：BST中序遍历为升序数组，则判断是否为升序即可，因判断升序过程只需前继节点，所以可以优化掉数组
int preVal = Integer.MIN_VALUE;

public boolean isBST(TreeNode root) {
    if (root == null) return false;
    if (root.left != null && !isBST(root.left)) return false;// 先判断左子树
    if (root.val <= preVal) return false;// 违反中序遍历升序排列
    preVal = root.val;// 遍历到自身，则记录自身值
    if (root.right != null && !isBST(root.right)) return false;// 再判断右子树
    return true;
}
```

### 判断AVL树

判断二叉树是否为AVL树，AVL树的左右子树高度差不超过1.

```java
public boolean isAVL(TreeNode root) {
    return dfs(root) != -1;
}

// 后序遍历：返回值表示子AVL树高度，-1表示不是AVL
int dfs(TreeNode root) {
    if (root == null) return 0;
    int left = dfs(root.left);
    if (left == -1) return -1;
    int right = dfs(root.right);
    if (right == -1) return -1;

    // 此时左子树和右子树都是AVL树
    if (Math.abs(left - right) > 1) return -1;
    return 1 + Math.max(left, right);// 此子树为AVL树，返回高度
}
```

### 二叉树最近公共祖先

力扣236题：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

```java
// 先序遍历：返回找到的p1或p2或公共祖先，否则返回null
TreeNode dfs(TreeNode root, TreeNode p1, TreeNode p2) {
    if (root == null) return null;
    // 当root为p1或p2时，直接返回root，此时root树要么只有1个，要么两个都有(此时p1/p2为p2/p1的祖先)
    if (root == p1 || root == p2) return root;

    TreeNode left = dfs(root.left, p1, p2);
    TreeNode right = dfs(root.right, p1, p2);
    // 左右子树都找到了，肯定分别为p1和p2，则返回root作为祖先
    if (left != null && right != null) return root;
    // 左右子树只找到1个，可能是p1/p2或公共祖先，直接返回
    if (left != null) return left;
    if (right != null) return right;
    return null;// 没找到
}
```

### 折纸问题

https://www.nowcoder.com/questionTerminal/430180b66a7547e1963b69b1d0efbd3c

![image-20220905170836831](数据结构.assets/image-20220905170836831.png)

```java
/* 前3次折叠：0表示凹，1表示凸
            0
        0   0   1
      0 0 1 0 0 1 1
      若以二叉树来看：不就是中序遍历吗？每个新折痕其左孩子为凹，右孩子为凸
            0
        0       1
      0   1   0   1
     */
// k表示当前第k层，n表示最大折叠次数
static void print(int k, int n, boolean ao) {
    if (k > n) return;
    print(k + 1, n, true);
    System.out.printf("%c ", ao ? '0' : '1');
    print(k+1,n,false);
}
```



# 图

## 无向图(待续)

## 有向图

### 有向图结构

有向图如下：保存了节点集合与边集合，可以由N*3矩阵得到一个有向图

```java
/**
 * 有向图
 *
 * @author fzk
 * @datetime 2022-08-19 10:29
 */
public class MyGraph {
    public HashMap<Integer, Node> nodes;
    public HashSet<Edge> edges;

    // matrix代表所有边， N*3矩阵
    // matrix[i]=[from节点, to节点, 边权重]
    public MyGraph(int[][] matrix) {
        this.nodes = new HashMap<>();
        this.edges = new HashSet<>();

        // 将输入转为图
        for (int i = 0; i < matrix.length; i++) {
            int from = matrix[i][0], to = matrix[i][1], weight = matrix[i][2];
            Node fromNode = this.nodes.get(from), toNode = this.nodes.get(to);
            if (fromNode == null) {
                fromNode = new Node(from);
                this.nodes.put(from, fromNode);
            }
            if (toNode == null) {
                toNode = new Node(to);
                this.nodes.put(to, toNode);
            }

            Edge edge = new Edge(weight, fromNode, toNode);
            this.edges.add(edge);
            fromNode.nextNodes.add(toNode);
            fromNode.edges.add(edge);
            fromNode.out++;
            toNode.in++;
            // 有向图
            // toNode.nextNodes.add(fromNode);
            // toNode.edges.add(edge);
        }
    }
}
```

有向图节点：有向图中一定要记录入度和出度，它非常有用如拓扑排序

```java
/**
 * @author fzk
 * @datetime 2022-08-19 10:32
 */
public class Node {
    public int value;
    public int in = 0;// 入度
    public int out = 0;// 出度
    public ArrayList<Node> nextNodes;
    public ArrayList<Edge> edges;

    public Node(int value) {
        this.value = value;
        this.nextNodes = new ArrayList<>();
        this.edges = new ArrayList<>();
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (int i = 0; i < this.nextNodes.size(); i++) {
            Node next = this.nextNodes.get(i);
            if (i != 0) sb.append(", ");
            sb.append(next.value);
        }
        sb.append(']');
        return "Node{" +
                "value=" + value +
                ", in=" + in +
                ", out=" + out +
                ", nextNodes=" + sb.toString() +
                '}';
    }
}
```

有向图边：

```java
/**
 * @author fzk
 * @datetime 2022-08-19 10:32
 */
public class Edge {
    public int weight;// 权重
    public Node from;// 边出发点
    public Node to;// 边终点

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```

### dfs和bfs

有向图dfs和无向图区别不大，都是用一个访问标记集合记录是否访问过：

不过下面这个不算真正的递归遍历，而是用栈模拟的递归遍历

```java
public static ArrayList<Node> dfs(MyGraph graph) {
    HashSet<Node> accessed = new HashSet<>();
    ArrayList<Node> result = new ArrayList<>();
    LinkedList<Node> stack = new LinkedList<>();

    for (Node node : graph.nodes.values()) {
        if (!accessed.contains(node))
            dfs(node, accessed, result, stack);
    }
    return result;
}

private static void dfs(Node node, HashSet<Node> accessed, 
                        ArrayList<Node> result, LinkedList<Node> stack) {
    if (node == null) return;

    stack.addLast(node);
    accessed.add(node);
    result.add(node);
    while (stack.size() > 0) {
        Node cur = stack.removeLast();
        for (Node next : cur.nextNodes) {
            if (!accessed.contains(next)) {
                accessed.add(next);

                // 这里再将此元素加入栈中，再最后进行break是为了完美的切合dfs访问节点顺序流程
                stack.addLast(cur);
                stack.addLast(next);

                // ---这里执行dfs操作
                result.add(next);
                // ---

                break;// break目的是为了完美切合dfs流程
            }
        }
    }
}
```

有向图宽度优先也和dfs差不多：一个用栈一个用队列的区别。

```java
public static ArrayList<Node> bfs(MyGraph graph) {
    ArrayList<Node> result = new ArrayList<>();
    HashSet<Node> accessed = new HashSet<>();// 已经访问过的标记
    LinkedList<Node> queue = new LinkedList<>();

    for (Node node : graph.nodes.values()) {
        if (!accessed.contains(node))
            bfs(node, accessed, queue, result);
    }
    return result;
}

private static void bfs(Node node, HashSet<Node> accessed, 
                       LinkedList<Node> queue, ArrayList<Node> result) {
    if (node == null) return;

    queue.addLast(node);
    accessed.add(node);
    result.add(node);
    while (queue.size() > 0) {
        Node cur = queue.removeFirst();
        for (Node next : cur.nextNodes) {
            if (!accessed.contains(next)) {
                accessed.add(next);
                queue.addLast(next);

                // ---这里执行bfs操作
                result.add(next);
                // ---
            }
        }
    }
}
```

### 有向环判断与拓扑排序

判断有向图的环其实很简单，就按照包依赖解析这种思想来做，当某个包解析时，递归解析其依赖包，若最后发现又依赖于前面尚在解析中的包，则出现了**循环依赖**，即有向环。

拓扑排序：用于决定按照什么顺序执行某些任务，如某些任务必须在另一些任务之前调度，这会构成一张有向调度图，拓扑排序就是如何调度这些任务。

思想：肯定是**入度为0的任务先调度**，此任务调度后将其指向的后继任务入度减1即可继续循环查找入度为0的任务，整个拓扑排序过程就是循环寻找入度为0结点，并将其从图中逻辑移除。

```java
/**
 * 拓扑排序以及有向环判断
 *
 * @author fzk
 * @datetime 2022-08-19 15:43
 */
public class TopoSort {
    // 判断有向图是否有环
    // 用途：包依赖解析，避免循环依赖
    public static boolean isHasCycle(MyGraph graph) {
        // 当有某个结点时说明在解析，为true表示解析完成，false表示解析进行中
        HashMap<Node, Boolean> parse = new HashMap<>();

        for (Node node : graph.nodes.values())
            dfsIsHasCycle(node, parse);
        return isCycleDependency;
    }

    private static boolean isCycleDependency = false;

    private static void dfsIsHasCycle(Node node, HashMap<Node, Boolean> parse) {
        if (isCycleDependency) return;
        // node解析过了
        if (parse.containsKey(node)) {
            // node正在解析说明出现循环依赖了！
            if (!parse.get(node)) {
                isCycleDependency = true;
            }
            return;
        }

        // 开始解析node
        parse.put(node, false);
        // dfs方式解析其依赖
        for (Node next : node.nextNodes) 
            dfsIsHasCycle(next, parse);
        
        // 解析完成
        parse.put(node, true);
    }

    // 有向图拓扑排序，也能根据这个判断是否有向环
    // 使用场景：任务依赖调度，如A-->B-->C，则任务调度顺序必须为[A, B, C]
    public static ArrayList<Node> topoSort(MyGraph graph) {
        // 0.有环图无拓扑排序
        // if (isHasCycle(graph)) return null;

        LinkedList<Node> zeroInNode = new LinkedList<>();// 入度为0的节点入队列
        HashMap<Node, Integer> nodeInMap = new HashMap<>();// 节点的剩余入度，若不想改变原始结构，则必须以其它结构保存其入度情况
        ArrayList<Node> result = new ArrayList<>();

        // 1.先查找入度为0的节点，它们最先执行
        for (Node node : graph.nodes.values()) {
            if (node.in == 0) zeroInNode.addLast(node);
            nodeInMap.put(node, node.in);
        }

        // 2.拓扑排序开始，将入度为0的节点逻辑上从有向图中去除，依次改变其它节点入度，一轮轮的找入度为0节点
        while (zeroInNode.size() > 0) {
            Node cur = zeroInNode.removeFirst();
            result.add(cur);
            // 逻辑上移除cur节点，修改其后继节点的入度
            for (Node next : cur.nextNodes) {
                Integer old = nodeInMap.put(next, nodeInMap.get(next) - 1);
                if (old == 1) zeroInNode.addLast(next);
            }
        }
        // 3.只要节点数量不对，肯定是因为有向环导致入度不为0
        if (result.size() != graph.nodes.size()) {
            throw new RuntimeException("拓扑排序发现出现了有向环");
        }
        return result;
    }
}
```

在上面拓扑排序第0步和第3步的有向环判断结果肯定是一致的，只需要保留其一即可。

### 有向环路劲

一个有向图中如何得到其有向环的所有节点呢？

要得到一条路劲，则必须**记录访问节点的前继节点**，从节点回退查找从而得到一条访问路劲；那么只要**找到环的节点之一**，就能**根据前继节点路劲回退查找环路劲**了。

```java
/**
 * 此类用于寻找有向图的环，
 * 关键在于记录访问节点的前继节点，当出现环时从末尾节点一直往回退从而得到环
 *
 * @author fzk
 * @datetime 2022-08-19 14:51
 */
public class DirectedCycle {
    private final HashSet<Node> accessed;
    /**
     * 记录到达key结点的前继结点value
     * 如A-->B， 那么在这里key=B， value=A
     */
    private final HashMap<Node, Node> preNode;
    private final HashSet<Node> onStack;// 表示节点是否在dfs的调用栈上
    /**
     * 若为空则无环，不为空则必为如下形式
     * 有向环：[A,x,x,x,A]
     */
    public LinkedList<Node> cycle = null;

    public DirectedCycle(MyGraph graph) {
        int n = graph.nodes.size();
        accessed = new HashSet<>(n);
        preNode = new HashMap<>(n);
        onStack = new HashSet<>(n);
        for (Node node : graph.nodes.values()) {
            if (!accessed.contains(node)) {
                accessed.add(node);
                dfs(node);
            }
        }
    }

    private void dfs(Node node) {
        if (hasCycle()) return;
        onStack.add(node);// 模拟dfs入栈

        for (Node next : node.nextNodes) {
            if (hasCycle()) return;
            else if (!accessed.contains(next)) {
                accessed.add(next);
                preNode.put(next, node);
                dfs(next);
            }
            // 该后继节点在dfs调用栈上，说明出现有向环了
            else if (onStack.contains(next)) {
                cycle = new LinkedList<>();
                // 这里必须从node开始往回找前继结点
                for (Node x = node; x != next; x = preNode.get(x))
                    cycle.addFirst(x);
                cycle.addFirst(next);
                cycle.addFirst(node);// 再加入node形成闭环，此时环：[A,x,x,x,A]
            }
        }

        onStack.remove(node);// 模拟dfs出栈
    }

    public boolean hasCycle() {
        return cycle != null;
    }

    /**
     * 如有环则返回环，无环返回null
     */
    public static LinkedList<Node> getCycle(MyGraph graph) {
        DirectedCycle directedCycle = new DirectedCycle(graph);
        if (directedCycle.hasCycle()) return directedCycle.cycle;
        else return null;
    }
}
```

有向图判断环除了这种模拟记录dfs调用栈，也可以按照上面那种有向环判断方式进行判断，反正核心在于前继节点路劲。

## 并查集union-find

将一组对象分为多个等价类(联通分量)，判断动态连通性。用例如社交网络的朋友的朋友。

```java
/**
 * @author fzk
 * @date 2022-08-26 10:44
 */
public class UF {
    // 每个节点在uf的前继结点，一开始是自己，然后是联通分量根结点，根结点合并时就不一定指向根结点了
    private final HashMap<Node, Node> nodesPre = new HashMap<>();
    // 以跟结点Node开始的联通分量大小
    private final HashMap<Node, Integer> ufSize = new HashMap<>();
    private int count = 0;// 联通分量数量

    public void union(Node p, Node q) {
        Node pRoot = find(p);
        Node qRoot = find(q);
        if (pRoot == qRoot) return;

        // 新链接，需要合并联通分量, 即合并跟触点
        // 将小树合并到大树，从而保证树高度不超过lgN
        int pSize = ufSize.get(pRoot), qSize = ufSize.get(qRoot);
        if (pSize < qSize) {
            // 将p联通分量合并到q
            nodesPre.put(pRoot, qRoot);
            ufSize.put(qRoot, pSize + qSize);
            //ufSize.remove(pRoot);// 可删可不删
        } else {
            // 将q联通分量合并到p
            nodesPre.put(qRoot, pRoot);
            ufSize.put(pRoot, pSize + qSize);
            //ufSize.remove(qRoot);// 可删可不删
        }
        count--;// 联通分量-1
    }

    // 查找p所在联通分量的根结点
    public Node find(Node p) {
        Node cur = p;
        Node pre = nodesPre.get(cur);
        // 新节点则构建新联通分量
        if (pre == null) {
            nodesPre.put(cur, cur);// 开始时每个触点只含有自己的分量
            ufSize.put(cur, 1);
            count++;// 联通分量+1
            return p;
        } else {
            // 旧节点则找到联通分量根结点
            while (cur != pre) {
                cur = pre;
                pre = nodesPre.get(pre);
            }
            return cur;
        }
    }

    public boolean connected(Node p, Node q) {
        return find(p) == find(q);
    }

    public int getCount() {
        return this.count;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = Integer.parseInt(scanner.nextLine());
        UF uf = new UF();
        HashMap<Integer, Node> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            String[] splits = scanner.nextLine().split(" ");
            int p = Integer.parseInt(splits[0]);
            int q = Integer.parseInt(splits[1]);
            Node pNode = map.getOrDefault(p, new Node(p));
            map.put(p,pNode);
            Node qNode = map.getOrDefault(q, new Node(q));
            map.put(q,qNode);
            if (uf.connected(pNode, qNode)) continue;
            uf.union(pNode, qNode);
            System.out.printf("新增连接：%d  %d\n", p, q);
        }
        System.out.println("联通分量：" + uf.getCount());
    }
}
```

时间复杂度：在最坏情况下，find()、connected()和union()的成本增长数量级为**lgN**。

### 路劲压缩union-find

在并查集中判断两节点是否相连，需要调用find()方法找到根触点，在上面那种方式已经保证查找时间复杂度低至lgN，但是**最好的情况是每个节点都直接指向其根触点**，为了减少修改次数，可以在遍历过程中顺便修改：

```java
// 查找p所在联通分量的根结点
public Node find(Node p) {
    Node cur = p;
    Node pre = nodesPre.get(cur);
    // 新节点则构建新联通分量
    if (pre == null) {
        nodesPre.put(cur, cur);// 开始时每个触点只含有自己的分量
        ufSize.put(cur, 1);
        count++;// 联通分量+1
        return p;
    } else {
        // 旧节点则找到联通分量根结点
        while (cur != pre) {
            cur = pre;
            pre = nodesPre.get(pre);
        }

        // 路劲压缩quick-union算法：
        // 将遇到的每个节点直接指向根触点
        Node pRoot = cur;
        cur = p;
        while ((pre = nodesPre.get(cur)) != pRoot) {
            nodesPre.put(cur, pRoot);
            cur = pre;
        }
        return pRoot;
    }
}
```

只需要在find()方法加1个循环即可。

注意：路劲压缩并不见得会比前面的方法性能强多少。在算法书p147中有描述。所以没必要去可以优化。

## 最小生成树

- 图的生成树：是无向图的一棵含有所有节点的无环连通子图 
- 最小生成树：加权无向图的一棵权值(树中所有边权值和)最小生成树。

### Kruskal算法

需要借助并查集实现。

```java
/**
 * 借助union-find实现的Kruskal算法最小生成树
 *
 * @author fzk
 * @date 2022-08-26 16:45
 */
public class KruskalMST {
    public static HashSet<Edge> kruskalMST(MyGraph graph) {
        UF uf = new UF();
        // 维护一个最小边的有限队列
        PriorityQueue<Edge> queue = new PriorityQueue<>(
                (a, b) -> a.weight - b.weight);
        queue.addAll(graph.edges);

        // 每次选择最小边将两棵树合并为一棵树
        HashSet<Edge> result = new HashSet<>();
        while (queue.size() > 0 && result.size() < graph.nodes.size() - 1) {
            Edge edge = queue.poll();
            Node from = edge.from, to = edge.to;
            // 用uf将不连通的两个子树合并
            if (!uf.connected(from, to)) {
                uf.union(from, to);
                result.add(edge);
            }
        }
        return result;
    }
}
```

## prim算法

先随机选个节点做最小生成树起始节点，然后每次从该树中能直接相连的新节点选择权重最小的一个边的新节点入树。

```java
/**
 * 无向图生成最小生成树
 * prim算法
 * 先随机选一个节点，以它出发每次选择最小的边的新节点，每次将新的节点加入最小树节点集合，下次又以该最小树集合中所有节点出发找新节点最小的边，直接所有节点入树
 *
 * @author fzk
 * @datetime 2022-09-05 17:35
 */
public class PrimMST {
    // 要求图必须是连续的
    // 若图连续，则相当于森林，多个图
    // 在下面取firstNode时，for循环所有节点去生成树即可生成多棵最小生成树
    public static HashSet<Edge> primMst(MyGraph graph) {
        // 当前构建的树包含的节点
        HashSet<Node> mstNodes = new HashSet<>();
        // 从这些节点出发可选的边
        PriorityQueue<Edge> queue = new PriorityQueue<>((a, b) -> a.weight - b.weight);
        // 最小生成树的边
        HashSet<Edge> mstEdges = new HashSet<>();


        Node firstNode = graph.nodes.values().iterator().next();
        mstNodes.add(firstNode);
        addAllEdgeToQueue(mstNodes, queue, firstNode);

        while (mstNodes.size() < graph.nodes.size() && queue.size() > 0) {
            Edge edge = queue.poll();
            // 此边的两个节点都已在树中，忽略
            if (mstNodes.contains(edge.from) && mstNodes.contains(edge.to)) continue;

            // 此最小边可用
            mstEdges.add(edge);// 新最小边入树
            Node next = null;
            // 肯定是to节点为新节点
            if (mstNodes.contains(edge.from)) next = edge.to;
            else next = edge.from;

            mstNodes.add(next);// 新节点入树
            addAllEdgeToQueue(mstNodes, queue, next);// 将当前新节点的新边加入队列中
        }
        return mstEdges;
    }

    // 加入某个新节点的新边入队列
    private static void addAllEdgeToQueue(HashSet<Node> mstNodes, PriorityQueue<Edge> queue, Node node) {
        for (Edge edge : node.edges) {
            // 如果头尾两个节点都包含在树中了，则该边无没必要进队列
            if (!mstNodes.contains(edge.to)) queue.add(edge);
        }
    }
}
```

## Dijkstra算法

这个算法的思想类似动态规划。适用范围：没有权值为负数的边。这是一种路由选择算法。

此算法用于在图中，从节点A到图中所有节点的最短路劲选择。

# 数学

## 质数

质数即除了1和它本身外没有其他因数的自然数。

力扣204题，统计小于n的所有质数个数，0<=n<=5*10<sup>6</sup>

### 暴力枚举

所谓枚举，就是从2开始一个个数，暴力解决问题。

```java
class Solution {
    public int countPrimes(int n) {
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            ans += isPrime(i) ? 1 : 0;
        }
        return ans;
    }

    public boolean isPrime(int x) {
        if(x<=1) return false;// 边界处理
        if(x&1==0) return false;// 先排除偶数
        for (int i = 3; i * i <= x; ++i) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```

时间复杂度：O(N*N<sup>1/2</sup>)；空间复杂度：O(1)

### 埃氏筛

该算法由希腊数学家厄拉多塞（EratosthenesEratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛
如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x… 一定不是质数，那么可以建立一个标记数组，对每个质数，标记其倍数为合数，这样之后遇到的只要没被标记过，就一定是质数(因为它不是任何小于它的数的倍数)。
在标记的时候，也不必从2x开始标记，因为2x一定被2这个质数标记过了，可以从x*x开始标记。

```java
public int countPrimes(int n) {
    if (n <= 1) return 0;
    // 埃氏筛
    boolean[] isPrime = new boolean[n + 1];
    Arrays.fill(isPrime, true);
    int count = 0;// 质数个数

    for (int i = 2; i < n; i++) {
        if (isPrime[i]) {// 没有被标记为false
            count++;
            // 开始埃氏筛标记
            for (long j = ((long) i * i); j < n; j += i)
                isPrime[(int) j] = false;
        }
    }
    return count;
}
```

时间复杂度：O(N lg(lgN))；空间复杂度：O(N)

# 排序算法

>特点：1.没有任何基于比较的算法能够保证使用少于 lg(N!)~NlgN 次比较将长度为N的数组排序。证明过程在算法第四版P177。

## 前言

笔记大部分知识点来自于《算法》第四版，也有参考博客。这里面前7种都是基于比较的排序。

![排序算法比较](数据结构.assets/排序算法比较.jpg)

## 0. 排序算法模板

```java
// 排序算法类的模板
public class Example {
    public static void sort(Comparable[] a){
       //各个排序算法的具体实现
    }

    private static boolean less(Comparable v,Comparable w){
        return v.compareTo(w)<0;
    }

    private static void exch(Comparable[] a,int i,int j){
        Comparable t=a[i];
        a[i]=a[j];
        a[j]=t;
    }
}
```

## 1. 初级排序

### 1.1 选择排序

- 思想：首先**找到数组中最小的元素，将它与数组第一个元素交换位置**。重复操作，直至有序。不断选择剩余元素中最小者，故称选择排序。

```java
/**
* 特点：与输入分布无关、数据移动最少(N次交换，线性关系，其他的任何算法都不具备)、不稳定
* 复杂度分析：
*   时间复杂度：n次交换，n*(n-1)/2次比较；O(N^2)
*   空间复杂度：O(1)
* @author fzkstart
* @create 2020-12-06 16:05
*/
public class Selection {
    public static void sort(Comparable[] a){
        int n=a.length;
        for(int i=0;i<n;i++){
            int minIndex=i;  //  最小元素的索引
            for(int j=i+1;j<n;j++)
                if(less(a[j],a[minIndex]))
                    minIndex=j;
            exch(a,i,minIndex);
        }
    }
}
```

### 1.2 插入排序

- 思想：想象为斗地主齐牌，将新牌插入有序序列中，将其余元素都右移。

```java
/**
* 特点：所需的时间取决于数组中元素的初始顺序，时间上：部分有序<随机数组<逆序数组
* 复杂度分析：
*      时间复杂度： 最坏情况：1/2N^2次比较1/2N^2次移动；O(N^2)
*                  最好情况：N-1次比较和0次移动; O(N)
*                  平均情况：1/4N^2次比较和1/4N^2移动; O(N^2)
*      空间复杂度：O(1)
* @author fzkstart
* @create 2020-12-06 16:57
*/
public class Insertion {
    public static void sort(Comparable[] a,int lo,int hi){
        //正向插入排序算法，升序，从左向右，稳定
        Comparable temp=null;
        int j=0;
        for(int i=lo+1;i<=hi;i++){
            temp=a[i];
            for(j=i;j>lo&&less(temp,a[j-1]);j--){
                a[j]=a[j-1];
            }
            a[j]=temp;
        }
    }
    public static void sortReverseStable(Comparable[] a){
        //反向插入排序算法，降序，从右向左,稳定
        int n=a.length;
        Comparable temp=null;
        int j=0;
        for(int i=n-2;i>=0;i--){
            temp=a[i];
            for(j=i;j<n-1&&less(temp,a[j+1]);j++){
                a[j]=a[j+1];
            }
            a[j]=temp;
        }
    }
}
```

#### 二分插入排序

优化待插入元素查找插入位置的过程，将O(n)优化为O(lgN)；**平均时间复杂度：O(NlgN)**

```java
// 二分插入排序
public static void binaryInsertSort(int[] arr, int start, int end) {
    if (start >= end) return;
    // i表示已经有序部分
    for (int i = start; i < end; i++) {
        int aj = arr[i + 1];// aj表示待插入元素
        // 1.aj不用插入，直接追加到有序序列末尾即可
        if (aj >= arr[i]) continue;// 这样可以避免二分查找

        // 2.二分查找最佳插入位置
        // 维护了left左边都是<=target，right右边都是>target
        // 那么最佳插入位置是left
        int left = start, right = i;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (arr[mid] <= aj) left = mid + 1;
            else right = mid - 1;
        }

        // 3.此时left就是第一个>aj的索引，也即aj将插入的索引
        if (i + 1 >= left)
            System.arraycopy(arr, left, arr, left + 1, i + 1 - left);
        arr[left] = aj;
    }
}
```

这里的关键在于如何**查找最佳插入位置即大于target的第一个索引**。


### 1.3 希尔排序

- 思想：对于大规模乱序的数组，插入排序很慢，因为它只会交换相邻的元素。为了加快速度，简单改进插入排序，交换不相邻的元素对数组局部排序，最终用插入排序对局部有序数组进行排序。

```java
/**
* 1.初级排序算法：
* 1.3 希尔排序
* 特点：1.是对插入排序的简单改进，类似于插入排序，但是增量为h，
*      即数组中任意间隔为h的元素都是有序的，即h有序数组。
*      2.希尔排序比插入排序和选择排序更高效，并且数组越大，优势越大；
*      因为它权衡了子数组的规模和有序性。
*      3.增量h的递增序列会影响算法性能，但在实际应用中区别不明显。
*      4.复杂度分析：希尔排序难以准确描述其性能
*              此例子中使用的递增序列在最坏情况下，比较次数和N^(3/2)成正比。
*          时间复杂度：O(N^3/2)
*          空间复杂度：O(1)
* @author fzkstart
* @create 2020-12-08 19:15
*/
public class Shell {
    public static void sort(Comparable[] a){
        //默认升序排序，Shell排序算法
        int n=a.length;
        int h=1;
        //h为间隔,此处选择较为简单的递增序列
        while(h<n/3) h=h*3+1;
        Comparable temp=null;
        int j=0;
        while(h>=1){
            for(int i=h;i<n;i++){
                temp=a[i];
                for(j=i;j>=h&&less(temp,a[j-h]);j-=h){
                    a[j]=a[j-h];
                }
                a[j]=temp;
            }
            h=h/3;
        }
    }
}
```


## 2. 归并排序

- 思想：一种递归排序算法。**将数组递归地分两半进行排序，然后将结果归并起来**。最吸引人的性质是能保证任意数组排序所需时间和NlogN成正比，但主要缺点是需要额外空间也和N成正比。

### 2.0 归并方法

```java
// 归并
public static void merge(Comparable[] a,Comparable[] aux,int lo,int mid,int hi){
    // 将a[lo..mid]和a[mid+1..hi]归并
    int i=lo,j=mid+1;
    for(int k=lo;k<=hi;k++)
        aux[k]=a[k]; // 将a[lo..hi]复制到aux[lo..hi]

    for(int k=lo;k<=hi;k++){
        if(i>mid) a[k]=aux[j++];
        else if(j>hi) a[k]=aux[i++];
        else if(less(aux[j],aux[i])) a[k]=aux[j++];
        else a[k]=aux[i++];
    }
}
```

### 2.1 自顶向下的归并排序

- 思想：递归归并，分治思想一种典型应用。

```java
/**
* 2. 归并排序
* 2.1 自顶向下的归并排序
* 特点：1.递归归并，体现分治思想，化整为零，递归解决
*      2.稳定性分析：具有稳定性
*      3.复杂度分析：
*          时间复杂度：O(NlogN);
*                      需要1/2NlgN~NlgN次比较，最多需要访问数组6NlgN次；
*                      归并树状图层数为lgN，每层归并最多访问6N次数组，
*                      2N用于复制，2N用于移动，2N用于比较；
*          空间复杂度：O(N)
*      4.性能优化：递归会使得小规模问题中方法的调用过于频繁，
*      可以尝试用插入排序处理小规模数组(如n<15)，一般能将归并排序的
*      运行时间缩短10%~15%。
* @author fzkstart
* @create 2020-12-09 10:06
*/
public class Merge {
    public static void sort(Comparable[]a){
        // 归并所需的辅助数组
        Comparable[] aux=new Comparable[a.length]; // 一次性分配空间
        sort(a,aux,0,a.length-1);
    }
    private static void sort(Comparable[]a,Comparable[] aux,int lo,int hi){
        // 将数组a[lo..hi]排序
        if(hi<=lo) return;
        int mid=(lo+hi)>>1;
        sort(a,aux,lo,mid);         // 将左半边排序
        sort(a,aux,mid+1,hi);       // 将右半边排序
        merge(a,aux,lo,mid,hi);     // 归并结果
    }
}
```

- 分析图：

![归并排序树状图](数据结构.assets/归并排序树状图.jpg)

- 性能优化：递归会使得小规模问题中方法的调用过于频繁，可以尝试用插入排序处理小规模数组(如n<15)，一般能将归并排序的运行时间缩短10%~15%。

### 2.2 自底向上的归并排序

- 思想：
  - 将一个大问题分割为小问题分别解决，然后用所有小问题的答案来解决整个大问题。
  - 先归并小数组，然后成对归并得到的子数组，直至将整个数组归并在一起。
  - 首先是两两归并，然后是四四归并、、、
- 算法实现：

```java
/**
 * 2.归并排序
 * 2.2 自底向上的归并排序
 * 特点：特点同自顶向下的归并排序
 *      当数组长度为2的幂时，两者的比较次数和访问次数同，其他情况次序会有所不同
 *      4.自底向上归并排序比较适合用于链表
 * 复杂度：
 *	时间：O(NlogN)
 * 	空间：O(N)
 * @author fzkstart
 * @create 2020-12-09 11:58
 */
public class MergeBU {
    public static void sort(Comparable[]a){
        int N=a.length; // 进行lgN次两两归并
        Comparable []aux=new Comparable[N]; // 归并所需的辅助数组
        for(int sz=1;sz<N;sz+=sz)  // sz是子数组的大小
            for(int lo=0;lo<N-sz;lo+=sz+sz) // lo:子数组索引
                merge(a,aux,lo,lo+sz-1,Math.min(lo+sz+sz-1,N-1));
    }
}
```

- 分析：**自底向上归并排序适合于链表，？？？**

自底向上相比于自定向下的**优势在于没有递归调用**，空间利用上和时间执行上都会更优。

## 3. 快速排序

- 思想：一种分治的排序算法。
- 特点

>1.应用最广泛的排序算法，原因是它实现简单、适用于各种不同的输入数据且在一般应用中比其他排序算法快得多。

>2.原地排序且时间复杂度O(NlgN)。快速排序的内循环比大多数排序算法都要短小，意味着它无论是理论上还是实际中都要更快。

>3.主要缺点是非常依赖随机性(元素分布)，性能可能下降成O(N^2)

### 3.1 二分法快速排序

- 思想：选取哨兵元素，将数组分为两半，左边<=哨兵，右边>哨兵，递归切分，当两个子数组都有序的时候，则数组有序。

```java
/**
 * 思想：该方法的关键在于切分：对于某个j，a[j]已经排定
 *      a[lo..j-1]<=a[j],a[j+1..hi]>a[j]
 * 1.缺点：在切分不平衡时，会变得极为低效；
 * 2.复杂度分析：
 *          时间复杂度：O(NlgN)，平均~2NlgN次比较，~1/3NlgN次交换；
 *                      最多~N^2次比较，随机打乱数组可以预防这种情况；
 *                      移动次数相对于归并排序更少；
 *          空间复杂度：O(lgN)，原地排序（只需要一个很小的辅助栈）
 * 3.算法改进：3.1.对于小数组，插入排序更快，因为递归调用sort()影响速度；
 *           3.2.第二个方法是使用子数组的一部分元素的中位数切分数组，代价是需要计算中位数
 * @author fzkstart
 * @create 2020-12-09 16:42
 */
public class Quick {
    public static int M=5;//参数M是切换到插入排序的小数组长度，5~15都可以

    public static <T> void quickSort(Comparable<T>[] arr, int start, int end) {
        if(end<=start+M){//切换到小数组的插入排序
            Insertion.sort(a,start,end);
            return;
        }
        // 0.随机选1个元素作哨兵并移到第一位
        exch(arr, start, ThreadLocalRandom.current().nextInt(start, end + 1));
        T pivot = (T) arr[start];
        // 1.切分：left左边都<=pivot，right右边都>pivot
        // arr[start..right-1]<=arr[right]<arr[left..end]
        int left = start, right = end;
        while (left <= right) {
            if (arr[left].compareTo(pivot) <= 0) left++;
            else {
                // 将其交换到后面
                Comparable<T> tmp = arr[left];
                arr[left] = arr[right];
                arr[right] = arr[left];
                right--;
            }
        }
        // 将pivot和right交换
        arr[start] = arr[right];
        arr[right] = (Comparable<T>) pivot;

        // 2.递归子数组排序
        quickSort(arr, start, right - 1);
        quickSort(arr, left, end);
    }
}
```

- 特点： 

  >1.内循环短小；内循环会用一个递增的索引将数组元素和切分元素比较，不仅简洁，而且迅速。
  >2.相比于归并排序，比较次数多39%，但是移动数据次数更少。因而快速排序一般更快。
  >3.不稳定。
  
- 分析：

  >1.快速排序**核心在于切分**，切分选择的哨兵元素又及其**依赖随机性**，有两种方式保持随机性，一种是随机打乱数组，另一种是随机选择一个切分元素。

  >2.当有大量的重复元素情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的改进潜力，将当前实现的线性对数级性能提高到线性级别。

### 3.2 三向切分快速排序

- 思想：在有很多重复元素时，快速排序左边的子数组有很多不必要排序的元素，因而产生了三向切分。但是在重复元素不多的时候，它又比标准二分法多使用了很多次交换。

```java
/**
 * 思想：当数组中存在大量重复元素，快速排序性能尚可，但还有巨大改进空间。
 *      将数组切分为三部分，分别对应小于、等于、大于切分元素。
 * 特点：1.对于存在大量重复元素的数组，归并排序时间复杂度是线性对数的，而三向切分则是线性的；
 *      2.三向切分快速排序对重复元素的适应性，使得其成为排序库函数的最佳算法选择；
 *      3.缺点：在数组中重复元素不多的情况下，它比标准二分法多了很多次交换。
 * @author fzkstart
 * @create 2020-12-09 22:28
 */
public class Quick3way {
    public static int M=5;//参数M是切换到插入排序的小数组长度，5~15都可以

    // 三向切分快排, 在重复元素很多时效果很好
    public static void quickSort3(int[] arr, int start, int end) {
        if(end<=start+M){//切换到小数组的插入排序
            Insertion.sort(a,start,end);
            return;
        }
        // 0.随机选1个元素作哨兵并移到第一位
        swap(arr, start, ThreadLocalRandom.current().nextInt(start, end + 1));
        int pivot = arr[start];
        // 1.三向切分
        // 0..lt-1  < pivot
        // lt..gt   = pivot
        // gt+1..end>pivot
        int lt = start, gt = end, i = start;
        while (i <= gt) {
            if (arr[i] < pivot) swap(arr, i++, lt++);
            else if (arr[i] > pivot) swap(arr, i, gt--);
            else i++;
        }

        quickSort3(arr, start, lt - 1);
        quickSort3(arr, gt + 1, end);
    }

    public static void swap(int[] arr, int i, int j) {
        if (i == j) return;
        // 异或方法交换值的时候，i不能等于j
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }
}
```

- 分析：
  1.排序库函数最佳选择；
  2.重复元素不多时，性能不如二分法快速排序。


## 4. 堆排序

>堆排序来自于基于堆的优先队列的实现，每次将堆顶元素删除即可得到一个有序序列。

### 4.1 堆

```java
/**
 * 小顶堆
 *
 * @author fzk
 * @date 2022-08-08 23:37
 */
public class MyHeap {
    int[] arr;
    int size;

    public MyHeap(int[] arr) {
        assert arr.length > 0;
        this.arr = arr;
        size = arr.length;

        // 1.构造小顶堆
        if (size > 1) {
            for (int k = (size - 2) >> 1; k >= 0; k--)
                sink(k);
        }
    }

    // 下沉
    public void sink(int k) {
        if (k == size - 1) return;
        int cur = k;
        while (true) {
            int minIndex = cur;
            int left = (cur << 1) + 1, right = (cur << 1) + 2;
            // 1.存在左子树 2k+1
            if (left < size && arr[left] < arr[minIndex])
                minIndex = left;

            // 2.存在右子树 2k+2
            if (right < size && arr[right] < arr[minIndex])
                minIndex = right;

            // 3.下沉
            if (minIndex != cur) {
                swap(cur, minIndex);
                cur = minIndex;
            } else break;
        }
    }

    // 上浮
    public void floatUp(int k) {
        assert k >= 0;
        if (k == 0) return;
        int cur = k;
        while (cur != 0) {
            int parent = (cur - 1) >> 1;
            if (arr[cur] < arr[parent]) {
                swap(cur, parent);
                cur = parent;
            } else break;
        }
    }

    // 取出heap首
    public int poll() {
        if (size == 0) throw new RuntimeException("heap is null");
        int v = arr[0];
        arr[0] = arr[--size];
        sink(0);
        // 缩容一半
        if (arr.length>10 && size<<1 < arr.length){
            int[] tmp = new int[arr.length>>1];
            System.arraycopy(arr, 0, tmp, 0, size);
            arr = tmp;
        }
        return v;
    }

    // 查看heap首
    public int peek() {
        if (size == 0) throw new RuntimeException("heap is null");
        return arr[0];
    }

    public void add(int v) {
        // 扩容1.5倍
        if (size == arr.length) {
            int[] tmp = new int[size + ((size+1) >> 1)];
            System.arraycopy(arr, 0, tmp, 0, size);
            arr = tmp;
        }
        arr[size] = v;
        // 上浮
        floatUp(size++);
    }

    private void swap(int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

### 4.2 基于最大堆的堆排序

- 思想：将最大堆的最大元素a[0]和a[n-1]交换,最大元素到达自己的位置，此时将堆长-1，再重新有序化堆，即可一步步将最大元素交换到自己的位置。
- 步骤：

>阶段1：构造最大堆，从最后一个非叶子节点开始下沉修复堆，循环至索引为0。只需要扫描一半元素即可，因为可以跳过大小为1的堆。（相当于堆合并）

>阶段2：下沉排序；将堆中最大元素删除，然后放入堆缩小后数组空出的位置。类似选择排序每次选择最大元素。

- 代码实现：

```java
/**
 * 4.堆排序
 * 思想：用数组模拟堆的完全二叉树。从右向左用下沉方法sink()构造子堆，
 * 如果一个节点左右子树已经是堆，再调用sink()，可以将它们变成一个堆。
 * 将堆的最大元素a[0]和a[n-1]交换,此时堆长-1，再重新有序化堆。重复操作直至堆空。
 * 特点：1.分两步：构造堆；下沉排序
 *      2.不稳定
 *      3.复杂度：
 *          时间复杂度：O(NlogN); 最多2NlgN+2N次比较和一半次数的交换；
 *                     2N来自于堆构造；每次下沉最多2NlgN比较
 *          空间复杂度：O(1),原地排序。
 *      4.唯一能够同时最优利用空间和时间的方法；在空间很紧张时很流行；
 *      5.缺点：现代系统很多应用很少使用它，因为它无法利用缓存。缓存未命中次数远高于相邻元素比较法，
 *       如快速排序、归并排序，甚至是希尔排序。
 * @author fzkstart
 * @create 2020-12-11 12:19
 */
public class Heap {
    public static void HeapSort(Comparable[] a){
        int n=a.length; // n为数组长度
        //  左子树和右子树分别是2k+1和2k+2

        //1.阶段一：for循环构造堆,此时a[0]为最大元素，最大堆
        for(int k=n/2-1;k>=0;k--)
            sink(a,k,n);
        //2.阶段二：下沉排序
        while(n>1){
            //while循环将a[0]和a[n-1]交换并修复堆（此时n--，堆长减1）,
            //通过sink()重新选择最大元素到a[0]
            exch(a,0,--n);
            sink(a,0,n);
        }
    }
    //下沉
    private static void sink(Comparable[] a,int k,int n){
        while(2*k+1<n){    //存在左子树
            int maxIndex = k*2+1; //指向左子树
            //如果有右子树，且右子树大于左子树，则将最大指针指向右子树
            if (maxIndex+1<n&&less(a[maxIndex],a[maxIndex+1]))
                maxIndex ++;
            //父节点是最大值时，退出循环
            if(!less(a[k],a[maxIndex])) break;
            //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。
            exch(a,k,maxIndex);
            k=maxIndex;
        }
    }
```

- 分析：此处构造的最大堆，然后将堆顶与堆尾交换，堆顶优先级下降，使用下沉修复堆（堆的有序化）。
  最小堆的构造只需改动一下sink()即可。

### 4.3 基于最小堆的堆排序

```java
/**
 * 基于最小堆的排序，这里会比最大堆排序稍微麻烦一点，最大堆排序看笔记
 * 每次只能选出堆顶最小的一个元素，将其和堆尾进行交换，再缩小堆长度，从堆顶进行下沉操作
 * 此时得到的是降序的，可以翻转为升序的
 */
public static void heapSort(int[] arr) {
    int n = arr.length;// n代表堆长度
    // 1.以下沉构建最小堆
    for (int k = (n >> 1) - 1; k >= 0; k--)
        sink(arr, k, n);

    // 2.while循环将a[0]和a[n-1]交换并修复堆（此时n--，堆长减1）,通过sink()重新选择最小元素到a[0]
    while (n > 1) {
        swap(arr,0,--n);
        sink(arr,0,n);
    }
    
    // 3.将降序数组翻转为升序(如果是最大堆，则不需要此步骤)
    for (int left = 0, right = arr.length - 1; left < right; left++, right--) {
        swap(arr,left,right);
    }
}
```

## 小结

![比较排序小结](数据结构.assets/比较排序小结.jpg)

1. 快速排序是最快的通用排序算法

   >内循环指令少，能利用缓存（总是顺序的访问数据）
   >但如果稳定性很重要而空间不是问题，归并排序可能最好。

2. 稳定的只有插入和归并，其中插入也是可以改为不稳定的。

3. Java系统库的排序算法：
   **java.util.Arrays.sort()**，它实际上是一系列的排序方法：

    - 每种原始数据类型都有一个不同的排序方法；
    - 一个适用于所有实现了Comparable接口的数据类型的排序方法；

 - 一个适用于所有实现了比较器接口Comparator的数据类型的排序方法；

   对原始数据使用**三向切分快速排序**，
   对引用数据类型使用**归并排序**。

   >这实际上也暗示着用速度和空间(对于原始数据类型)来换取稳定性(对引用数据类型)。

4. 实际问题解决：目前在刷题中，其实对于排序本身的要求并不高，更多是在要求用排序算法的思想来解决问题。学习排序算法，应该更关注于它本身的实现所体现的思想，而不是真的为了排序。

## 5.基数排序

就是对数组元素按key进行分类，或者说是分桶，再将这些元素按桶的顺序排放，一个桶放完再放下一个桶。

高位优先的话，则对各个桶内元素递归处理。

低位优先的话，则对数组所有元素循环分桶排序。

### 低位优先排序

其实低位优先排序算法在排序整数时不如前面几种比较排序算法，因为不能排序负数和小数，**它一般排序字符串会比较好**，对于字符串的低位优先排序请看字符串排序部分，这里不再赘述。

低位优先数字排序：就是从低位到高位每一位按0~9分类进行排序。

因为高位是后进行分类排序，所以高位不同的两个数由高位决定顺序；

因为从低位开始分类排序且分类排序具有稳定性，当两个数低位不同而高位相同时，低位就决定顺序。

```java
/**
 * 低位优先排序
 * 时间复杂度：O(d*n), d为最大数的位数
 * 空间复杂度：O(n+radix)
 * 核心思想：将元素按各个位上的值分片，切分d次，每次切分为10份
 *
 * @author fzk
 * @date 2022-08-09 13:47
 */
public class LsdSort {
    // 低位优先排序，只能排序非负整数
    public static void lsdSort(int[] arr, int start, int end) {
        int digit = getMaxDigit(arr, start, end);
        int[] aux = new int[end - start + 1];// 辅助数组
        for (int d = 1; d <= digit; d++) {// 有多少位就分类多少次
            // 10个空间
            // count[i]表示低位优先第d位是i的数的个数
            // 前缀和累加之后
            // count[i]表示低位优先第d位是0..i的数的个数
            int[] count = new int[10];
            // 1.统计分类个数
            for (int i = start; i <= end; i++) {
                count[getDigit(arr[i], d)]++;
            }
            // 2.前缀和累加，目的：将分类频数转为分类的末尾索引
            for (int i = 1; i < 10; i++) {
                count[i] += count[i - 1];
            }
            // 3.分类元素, 从后遍历到前的目的是保证稳定性
            for (int i = end; i >= start; i--) {
                aux[--count[getDigit(arr[i], d)]] = arr[i];
            }
            // 4.回写
            //System.arraycopy(aux, 0, arr, start, end - start + 1);
            // 4.翻转输入输出，此方式比回写效率好点
            int[] tmp = arr;
            arr = aux;
            aux = tmp;
        }
        // 如果进行了奇数次分类排序: 正确排序结果存储在内建的辅助数组中，需将正确结果拷贝到输入参数最开始指向的那块内存的数组
        // 如果进行了偶数趟排序: 第偶数趟排序的结果实际存储在输入参数最开始指向的数组内存, 正确;
        if ((digit & 1) == 1)
            System.arraycopy(arr, 0, aux, 0, aux.length);
    }

    // 获取数组内最大值的位数
    static int getMaxDigit(int[] arr, int start, int end) {
        int max = arr[start];
        for (int i = start + 1; i <= end; i++) {
            if (arr[i] > max) max = arr[i];
        }
        int result = 0;
        while (max > 0) {
            result++;
            max = max / 10;
        }
        return result;
    }

    // 获得val的低位优先第d位的数字
    static int getDigit(int val, int d) {
        return (val / ((int) Math.pow(10, d - 1))) % 10;
    }
}
```

## 6.排序算法模板汇总

记录了上述几种排序算法，并以jdk的实现摘抄了**TimSort**和**双枢轴快排**：

```java
/**
 * 记录一些排序算法模板
 *
 * @author fzk
 * @date 2021-11-27 13:06
 */
public class MySortUtil {

    /**
     * 插入排序 <br/>
     * 稳定性 <br/>
     * 时间复杂度: 平均:O(N^2)  最好: O(N)  最坏: O(N^2) <br/>
     * 空间复杂度：O(1) <br/>
     */
    public static void insertSort(int[] arr, int left, int right) {
        // 从左向右插入, 保证 左边有序
        for (int i = left, j = i; i < right; j = ++i) {
            int ai = arr[i + 1];
            // 这里不采用swap，而是右移，可以减少一半交换
            while (ai < arr[j]) {
                arr[j + 1] = arr[j];
                if (j-- == left) break;
            }
            arr[j + 1] = ai;
        }
    }

    /**
     * 二分插入排序
     * 在插入排序的基础上采用了二分查找，优化了查找性能，在基本有序的情况下，效率反而因二分查找下降
     * 不稳定
     * 时间复杂度：平均O(N*N) 最好：O(N) 最坏：N(N^2)
     *
     * @apiNote 在和基本插入排序相比中，数组长度越长，优化越明显，但是在长数组中，快速排序效率会好很多
     */
    public static void divideInsertSort(int[] arr, int left, int right) {
        // 二分查找插入排序
        for (int i = left, j = i; i < right; j = ++i) {
            int ai = arr[i + 1];
            int lo = left, high = i;
            while (lo <= high) {
                int mid = (lo + high) >> 1;
                if (arr[mid] > ai) high = mid - 1;
                else if (arr[mid] == ai) {
                    lo = mid + 1;
                    break;
                } else
                    lo = mid + 1;
            }
            // 将ai移动到arr[lo]哦
            while (lo <= j) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = ai;
        }
    }

    /**
     * 归并排序: 性能不受输入数据的影响, 始终都是O(NlogN)的时间复杂度, 代价是需要额外的内存空间    <br/>
     * 采用分治法(Divide and Conquer) 的一个非常典型的应用     <br/>
     * 稳定性      <br/>
     * 时间复杂度：O(NlogN)
     * <P>
     * 需要1/2NlgN~NlgN次比较，最多需要访问数组6NlgN次；
     * 归并树状图层数为lgN，每层归并最多访问6N次数组，
     * 2N用于复制，2N用于移动，2N用于比较；
     * </p>
     * <p>
     * 性能优化：递归会使得小规模问题中方法的调用过于频繁，
     * 可以尝试用插入排序处理小规模数组(如n<15)，一般能将归并排序的
     * 运行时间缩短10%~15%。
     * </p>
     * 空间复杂度：O(N)
     */
    public static int[] mergeSort(int[] nums) {
        int len = nums.length;
        int[] res = new int[len];
        System.arraycopy(nums, 0, res, 0, len);//拷贝副本
        merge(res, new int[len], 0, len - 1);// 将副本排序，不破坏原数组
        return res;
    }

    private static void merge(int[] nums, int[] cache, int lo, int high) {
        if (lo >= high) return;

        // 小规模问题直接插入排序
        if (lo + 3 > high) {
            insertSort(nums, lo, high);
            return;
        }

        int mid = (lo + high) >> 1;
        merge(nums, cache, lo, mid);// 左边排序
        merge(nums, cache, mid + 1, high);// 右边排序
        // 归并操作
        // 将nums[lo..mid]和nums[mid+1..hi]归并
        // 将nums[lo..hi]复制到cache[lo..hi]
        System.arraycopy(nums, lo, cache, lo, high + 1 - lo);

        int i = lo, j = mid + 1, index = lo;
        while (i <= mid && j <= high) {
            if (cache[i] <= cache[j])
                nums[index++] = cache[i++];
            else nums[index++] = cache[j++];
        }
        while (i <= mid) nums[index++] = cache[i++];
        while (j <= high) nums[index++] = cache[j++];
    }

    /**
     * 基于最小堆的排序，这里会比最大堆排序稍微麻烦一点，最大堆排序看笔记
     * 每次只能选出堆顶最小的一个元素，将其和堆尾进行交换，再缩小堆长度，从堆顶进行下沉操作
     * 此时得到的是降序的，可以翻转为升序的
     */
    public static void heapSort(int[] arr) {
        int n = arr.length;// n代表堆长度
        // 1.以下沉构建最小堆
        for (int k = (n >> 1) - 1; k >= 0; k--)
            sink(arr, k, n);

        // 2.while循环将a[0]和a[n-1]交换并修复堆（此时n--，堆长减1）,通过sink()重新选择最小元素到a[0]
        while (n > 1) {
            int tmp = arr[0];
            arr[0] = arr[n - 1];
            arr[n - 1] = tmp;
            // 堆缩容并下沉操作
            sink(arr, 0, --n);
        }
        // 3.将降序数组翻转为升序(如果是最大堆，则不需要此步骤)
        for (int left = 0, right = arr.length - 1; left < right; left++, right--) {
            int tmp = arr[left];
            arr[left] = arr[right];
            arr[right] = tmp;
        }
    }

    /**
     * 下沉，最小堆
     *
     * @param arr 堆
     * @param k   需要下沉的堆顶索引，其左子树为2k+1，右子树为2k+2
     * @param n   堆长度
     */
    public static void sink(int[] arr, int k, int n) {
        int leftIndex, rightIndex, minIndex;
        while ((leftIndex = (k << 1) + 1) < n) {// 即存在左子树
            minIndex = k;
            if (arr[leftIndex] < arr[k]) minIndex = leftIndex;

            // 如果存在右子树
            if ((rightIndex = (k << 1) + 2) < n && arr[rightIndex] < arr[minIndex])
                minIndex = rightIndex;

            // 将最小的移到父节点k处
            if (k != minIndex) {
                int tmp = arr[k];
                arr[k] = arr[minIndex];
                arr[minIndex] = tmp;
                k = minIndex;// 循环下沉
            } else break;// 父节点是最小结点，则下沉结束
        }
    }

    /**
     * 上浮，最小堆
     *
     * @param arr 堆
     * @param k   需要上浮的索引，必须是刚加入堆的最后一个结点
     */
    public static void floatUp(int[] arr, int k) {
        int parentIndex;// 父节点索引为(k-1)/2
        while ((parentIndex = ((k - 1) >> 1)) >= 0) {
            if (arr[k] < arr[parentIndex]) {
                int tmp = arr[parentIndex];
                arr[parentIndex] = arr[k];
                arr[k] = tmp;
                k = parentIndex;// 循环上浮
            } else break;// 上浮完成
        }
    }

    /**
     * 基本快速排序 二分法
     * 不稳定
     * <p>
     * 时间复杂度: 平均：O(NlogN) 最坏: O(N^2) 最好: O(NlogN) <br/>
     * 空间复杂度：O(log n) 递归调用栈
     */
    public static void quickSort(int[] nums, int left, int right) {
        if (left < right) {
            // 小数组 插入排序
            if (left + 5 > right) {
                insertSort(nums, left, right);
                return;
            }

            // 以第一个元素进行切分
            int sentinel = nums[left];// 以左边元素为哨兵
            int i = left, j = right;
            while (i < j) {
                while (i <= j && nums[i] <= sentinel) i++; // 找到左边大于哨兵的
                while (i <= j && nums[j] > sentinel) j--;   // 找到右边小于等于哨兵的

                // 这里存在将等于哨兵的进行交换的情况：如果非常多的重复元素，建议用三向切分快速排序
                //  i < j 代表未切分完成，则交换这两个元素
                if (i < j) {
                    int tem = nums[i];
                    nums[i] = nums[j];
                    nums[j] = tem;
                }
            }
            // 切分完成后：此时 j右边都是大于哨兵的  i左边都是小于等于哨兵的 i=j+1
            nums[left] = nums[j]; // 将哨兵与右边第一个小于等于哨兵的元素进行交换
            nums[j] = sentinel;

            quickSort(nums, left, j - 1);
            quickSort(nums, i, right);
        }
    }

    /**
     * 双枢轴快速排序: 来源于jdk
     *
     * @see java.util.DualPivotQuicksort
     */
    public static void dualPivotQuickSort(int[] a, int left, int right) {
        int length = right - left + 1;

        // Use insertion dualPivotQuickSort on tiny arrays
        if (length < 47) {
            insertSort(a, left, right);
            return;
        }

        // 长度除以7的近似值
        int seventh = (length >> 3) + (length >> 6) + 1;
        // 选择与中心元素间隔均匀的5个基准元素
        int e3 = (left + right) >>> 1; // 中心元素
        int e2 = e3 - seventh;
        int e1 = e2 - seventh;
        int e4 = e3 + seventh;
        int e5 = e4 + seventh;

        // 对5个基准元素按插入排序进行排序
        if (a[e2] < a[e1]) {
            int t = a[e2];
            a[e2] = a[e1];
            a[e1] = t;
        }

        if (a[e3] < a[e2]) {
            int t = a[e3];
            a[e3] = a[e2];
            a[e2] = t;
            if (t < a[e1]) {
                a[e2] = a[e1];
                a[e1] = t;
            }
        }
        if (a[e4] < a[e3]) {
            int t = a[e4];
            a[e4] = a[e3];
            a[e3] = t;
            if (t < a[e2]) {
                a[e3] = a[e2];
                a[e2] = t;
                if (t < a[e1]) {
                    a[e2] = a[e1];
                    a[e1] = t;
                }
            }
        }
        if (a[e5] < a[e4]) {
            int t = a[e5];
            a[e5] = a[e4];
            a[e4] = t;
            if (t < a[e3]) {
                a[e4] = a[e3];
                a[e3] = t;
                if (t < a[e2]) {
                    a[e3] = a[e2];
                    a[e2] = t;
                    if (t < a[e1]) {
                        a[e2] = a[e1];
                        a[e1] = t;
                    }
                }
            }
        }


        // Pointers
        int less = left;  // center part 的第一个元素
        int great = right; // right part 的第一个元素前一个索引，切分完成后center part的最后一个元素

        // 这5个基准元素中只要有相同的存在就转为单枢轴快速排序
        if (a[e1] != a[e2] && a[e2] != a[e3] && a[e3] != a[e4] && a[e4] != a[e5]) {
            /*
             * 使用五个排序基准元素中的第二个和第四个作为枢轴
             * pivot1必须小于pivot2
             */
            int pivot1 = a[e2];
            int pivot2 = a[e4];

            /*
             * 要排序的第一个和最后一个元素被移动到以前由枢轴占据的位置。
             * 分区完成后，枢轴被交换回其最终位置，并从后续排序中排除。
             */
            a[e2] = a[left];
            a[e4] = a[right];

            /*
             * 跳过小于或大于枢轴值的元素
             */
            while (a[++less] < pivot1) ;
            while (a[--great] > pivot2) ;

            /*
             * Partitioning:
             *
             *   left part           center part                   right part
             * +--------------------------------------------------------------+
             * |  < pivot1  |  pivot1 <= && <= pivot2  |    ?    |  > pivot2  |
             * +--------------------------------------------------------------+
             *               ^                          ^       ^
             *               |                          |       |
             *              less                        k     great
             *
             * Invariants:
             *
             *              all in (left, less)   < pivot1
             *    pivot1 <= all in [less, k)     <= pivot2
             *              all in (great, right) > pivot2
             *
             * Pointer k is the first index of ?-part.
             */
            outer:
            for (int k = less - 1; ++k <= great; ) {
                int ak = a[k];
                if (ak < pivot1) { // 移动 a[k] 到 left part
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else if (ak > pivot2) { // 移动 a[k] 到 right part
                    while (a[great] > pivot2) {
                        if (great-- == k) {
                            break outer;
                        }
                    }
                    if (a[great] < pivot1) { // a[great] <= pivot2
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else { // pivot1 <= a[great] <= pivot2
                        a[k] = a[great];
                    }
                    a[great] = ak;
                    --great;
                }
            }

            // 交换枢轴到它们最终位置
            a[left] = a[less - 1];
            a[less - 1] = pivot1;
            a[right] = a[great + 1];
            a[great + 1] = pivot2;

            // 递归排序左右部分，不包括已知的枢轴
            dualPivotQuickSort(a, left, less - 2);
            dualPivotQuickSort(a, great + 2, right);

            /*
             * 如果中心部分太大（即> 4/7），将内部枢轴值交换到末端
             */
            if (less < e1 && e5 < great) {
                // 跳过与枢轴值相等的元素
                while (a[less] == pivot1) {
                    ++less;
                }

                while (a[great] == pivot2) {
                    --great;
                }

                /*
                 * Partitioning:
                 *
                 *   left part         center part                  right part
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             less                      k     great
                 *
                 * Invariants:
                 *
                 *              all in (*,  less) == pivot1
                 *     pivot1 < all in [less,  k)  < pivot2
                 *              all in (great, *) == pivot2
                 *
                 * Pointer k is the first index of ?-part.
                 */
                outer:
                for (int k = less - 1; ++k <= great; ) {
                    int ak = a[k];
                    if (ak == pivot1) { // Move a[k] to left part
                        a[k] = a[less];
                        a[less] = ak;
                        ++less;
                    } else if (ak == pivot2) { // Move a[k] to right part
                        while (a[great] == pivot2) {
                            if (great-- == k) {
                                break outer;
                            }
                        }
                        if (a[great] == pivot1) { // a[great] < pivot2
                            a[k] = a[less];
                            /*
                             * 即使a[great] 等于pivot1，如果a[great] 和pivot1 是不同符号的浮点零，
                             * 赋值a[less] = pivot1 也可能是不正确的。
                             * 因此，在 float 和 double 排序方法中，我们必须使用更准确的赋值 a[less] = a[great]。
                             */
                            a[less] = pivot1;
                            ++less;
                        } else { // pivot1 < a[great] < pivot2
                            a[k] = a[great];
                        }
                        a[great] = ak;
                        --great;
                    }
                }
            }

            // 递归排序中间部分
            dualPivotQuickSort(a, less, great);

        }
        // 5个基准元素存在相同的情况下，就执行单枢轴排序
        else {
            // 以e3作为枢轴
            int pivot = a[e3];

            /*
             * 三向切分
             *
             *   left part    center part              right part
             * +-------------------------------------------------+
             * |  < pivot  |   == pivot   |     ?    |  > pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             less            k      great
             *
             * Invariants:
             *
             *   all in (left, less)   < pivot
             *   all in [less, k)     == pivot
             *   all in (great, right) > pivot
             *
             * Pointer k is the first index of ?-part.
             */
            for (int k = less; k <= great; ++k) {
                if (a[k] == pivot) {
                    continue;
                }
                int ak = a[k];
                if (ak < pivot) { // 移动 a[k] 到 left part
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else { // a[k] > pivot - 移动 a[k] 到 right part
                    while (a[great] > pivot) {
                        --great;
                    }
                    if (a[great] < pivot) { // a[great] <= pivot
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else { // a[great] == pivot
                        /* 即使 a[great] 等于 pivot，赋值 a[k] = pivot 也可能是不正确的，
                         * 如果 a[great] 和 pivot 是不同符号的浮点零。因此，在 float 和 double 排序方法中，
                         * 我们必须使用更准确的赋值 a[k] = a[great]。
                         */
                        a[k] = pivot;
                    }
                    a[great] = ak;
                    --great;
                }
            }

            // 递归排序left part和 right part
            dualPivotQuickSort(a, left, less - 1);
            dualPivotQuickSort(a, great + 1, right);
        }
    }

    /**
     * 归并排序中的最大运行次数
     */
    private static final int MAX_RUN_COUNT = 67;

    public static void timSort(int[] a, int left, int right) {
        doTimSort(a, left, right, null, 0, 0);
    }

    /**
     * TimSort 高级merge sort 来源于jdk
     *
     * @param work     工作数组,可为null
     * @param workBase 工作数组中可用空间的来源
     * @param workLen  工作数组可用大小
     * @see java.util.DualPivotQuicksort#sort(int[], int, int, int[], int, int)
     */
    private static void doTimSort(int[] a, int left, int right, int[] work, int workBase, int workLen) {
        // 小数组用快速排序
        if (right - left < 286) {
            dualPivotQuickSort(a, left, right);
            return;
        }

        /*索引 run[i] 是第 i 个run的开始索引（升序或降序）*/
        int[] run = new int[MAX_RUN_COUNT + 1];
        int count = 0;
        run[0] = left;

        // 检查数组是否已经有序
        for (int k = left; k < right; run[count] = k) {
            // 数组开头的相等项
            while (k < right && a[k] == a[k + 1])
                k++;
            if (k == right) break;  // 全部相等则退出循环
            if (a[k] < a[k + 1]) { // 升序run
                while (++k <= right && a[k - 1] <= a[k]) ;
            } else if (a[k] > a[k + 1]) { // 降序run
                while (++k <= right && a[k - 1] >= a[k]) ;
                // 将降序run调整为升序run
                for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                    int t = a[lo];
                    a[lo] = a[hi];
                    a[hi] = t;
                }
            }

            // 合并因调整序列之后出现的连续升序的两个run
            if (run[count] > left && a[run[count]] >= a[run[count] - 1]) {
                count--;
            }

            /*
             * 如果数组切分出来的run非常多，说明数组不是高度结构化的，
             * 使用快速排序而不是归并排序。
             */
            if (++count == MAX_RUN_COUNT) {
                dualPivotQuickSort(a, left, right);
                return;
            }
        }

        // 这些 不变量 应该为true:
        //    run[0] = 0
        //    run[<last>] = right + 1; (terminator)

        if (count == 0) {
            // 1个run，直接返回
            return;
        } else if (count == 1 && run[count] > right) {
            /* 无论是一个升序run，还是一个降序被调整为升序的run
               总是检查最后一个run是不是一个正确的终止符
               否则我们将有一个未终止的尾随运行，以处理下游。*/
            return;
        }
        right++;
        if (run[count] < right) {
            /*转角情况：最后的运行不是终结者。
            如果最终run是equal run ,或者最后是单元素run，则可能会发生这种情况。
            通过在末尾添加适当的终止符来修复。请注意，我们以 (right + 1) 终止*/
            run[++count] = right;
        }

        // 确定合并的交替基准
        byte odd = 0;
        for (int n = 1; (n <<= 1) < count; odd ^= 1) ;

        // 使用或创建缓存数组来归并
        int[] b;                 // 缓冲数组;
        int ao, bo;              // 'left' 的数组偏移量
        int blen = right - left; // b数组需要的长度
        if (work == null || workLen < blen || workBase + blen > work.length) {
            work = new int[blen];
            workBase = 0;
        }
        if (odd == 0) {
            System.arraycopy(a, left, work, workBase, blen);
            b = a;
            bo = 0;
            a = work;
            ao = workBase - left;
        } else {
            b = work;
            ao = 0;
            bo = workBase - left;
        }

        // 合并
        for (int last; count > 1; count = last) {
            for (int k = (last = 0) + 2; k <= count; k += 2) {
                int hi = run[k], mi = run[k - 1];
                for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {
                    if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                        b[i + bo] = a[p++ + ao];
                    } else {
                        b[i + bo] = a[q++ + ao];
                    }
                }
                run[++last] = hi;
            }
            if ((count & 1) != 0) {
                for (int i = right, lo = run[count - 1]; --i >= lo;
                     b[i + bo] = a[i + ao]
                )
                    ;
                run[++last] = right;
            }
            int[] t = a;
            a = b;
            b = t;
            int o = ao;
            ao = bo;
            bo = o;
        }
    }

    private static void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```



# 字符串

## 字符串排序

### 键索引计数法

其实就是对数组元素按不同的key进行统计计数，然后将数组中元素按照key分布的起始索引排序。它是字符串低位优先和高位优先排序的基础。

### 低位优先排序

字符串的低位优先排序：就是从低位到高位每一位按字母表进行分类排序。

因为高位是后进行分类排序，所以高位不同的两个字符串由高位决定顺序；

因为从低位开始分类排序且分类排序具有稳定性，当两个字符串低位不同而高位相同时，低位就决定顺序。

```java
/**
 * 低位优先字符串排序
 * 时间复杂度：O(wn)
 * 空间复杂度：O(n+r)
 * 优点：低位优先分类可以非常巧妙的将字符串按照字典序升序排列，且不使用递归；线性时间排序算法
 * 缺点：大部分字符串很短，但某条字符串超长时会进行很多不必要统计，此时不如 高位优先字符串排序 和 比较排序
 */
public static void lsdStrSort(String[] strings) {
    // 通过低位的w个字符进行字符串排序
    int w = 0;
    for (String str : strings) {
        if (str.length() > w) w = str.length();
    }
    int n = strings.length;
    int r = 128;// ASCII字符
    String[] aux = new String[n];// 辅助数组
    for (int index = w - 1; index >= 0; index--) {// 对字符串数组分类w次就排序好了
        // 129个桶作分类统计
        // count[i]表示高位优先第d位字符type为i的元素个数
        // 前缀和累加之后
        // count[i]表示高位优先第d位字符type为0..i的元素个数
        int[] count = new int[r + 1];
        // 1.统计频率
        for (String str : strings)
            count[getCharType(str, index)]++;

        // 2.前缀和累加，目的：将分类频数转为分类的末尾索引
        for (int j = 1; j < r + 1; j++)
            count[j] += count[j - 1];

        // 3.分类元素, 从后遍历到前的目的是保证稳定性
        for (int i = strings.length - 1; i >= 0; i--) {
            String str = strings[i];
            aux[--count[getCharType(str, index)]] = str;
        }

        // 4.回写
        System.arraycopy(aux, 0, strings, 0, n);
    }
}

static int getCharType(String str, int index) {
    if (index >= str.length()) return 0;// 在字符超过边界时返回特殊值分类0，它们应该排序在最前面
    return str.charAt(index) + 1;// 其他则为字符的值+1作为分类
}
```

它的缺点正是高位优先排序擅长的，而高位优先排序的缺点正是低位优先排序强势的地方。

### 高位优先排序

高位优先类似于快排，快排一次切分为两部分或三部分，而高位优先一次切分为129份。

高位优先字符串排序就是将128个ASCII码字符作为128个类别，然后字符串结束为一个特殊类别，总共129个类进行字符串数组划分。

```java
package leetcode;

import java.util.Arrays;
import java.util.concurrent.ThreadLocalRandom;

/**
 * 高位优先字符串排序
 * 每次将字符串分为129个子数组，对后面128个进行递归调用
 * 时间复杂度：O(wN),w为最长字符串长度
 *      一般情况，高位优先只会检查足以区别字符串所需字符，是亚线性的
 *      最坏情况，所有字符串相等，线性O(wN)，和低位优先排序相同
 * 空间复杂度：O(N+rw)，N为辅助数组大小，w为最长字符串长度，r为分类数量
 *
 * @author fzk
 * @date 2022-08-09 22:28
 */
public class MsdSort {
    public static void main(String[] args) {
        String[] strings = new String[10];
        for (int i = 0; i < 10; i++) {
            int[] arr = ThreadLocalRandom.current().ints(1 + i, 'a', 'c').toArray();
            StringBuilder sb = new StringBuilder();
            for (int v : arr) {
                sb.append((char) v);
            }
            strings[i] = sb.toString();
        }
        System.out.println(Arrays.toString(strings));
        msdStrSort(strings);
        System.out.println(Arrays.toString(strings));
    }

    public static void msdStrSort(String[] strings) {
        String[] aux = new String[strings.length];// 辅助数组
        sort(strings, aux, 0, strings.length - 1, 0);
    }

    // 将字符串按照第d个字符切分为129个子数组，并对后128个子数组递归调用切分排序
    private static void sort(String[] strings, String[] aux, int start, int end, int d) {
        if (start >= end) return;
        // 小数组用最好插排解决
        //        if (start + 15 >= end) {
        //            Arrays.sort(strings, start, end + 1);
        //            return;
        //        }
        int r = 128;// ASCII字符
        // 129个桶作分类统计
        // count[i]表示高位优先第d位字符type为i的元素个数
        // 前缀和累加之后
        // count[i]表示高位优先第d位字符type为0..i的元素个数
        int[] count = new int[r + 1];
        // 1.统计频率
        for (int i = start; i <= end; i++)
            count[getCharType(strings[i], d)]++;

        // 2.前缀和累加，目的：将分类频数转为分类的末尾索引
        for (int j = 1; j < r + 1; j++)
            count[j] += count[j - 1];

        // 3.分类元素, 从后遍历到前的目的是保证稳定性
        for (int i = end; i >= start; i--) {
            String str = strings[i];
            aux[--count[getCharType(str, d)] + start] = str;
        }

        // 4.回写
        System.arraycopy(aux, start, strings, start, end - start + 1);

        // 5.递归，此时需要跳过字符串到末尾的子数组
        for (int i = 1; i < r + 1; i++) {
            // 要注意此时count[i]为高位优先第d位字符type为0..i-1的元素个数
            sort(strings, aux, start + count[i],
                 (i != r) ? (start + count[i + 1] - 1) : end, d + 1);
        }
    }

    static int getCharType(String str, int index) {
        if (index >= str.length()) return 0;// 在字符超过边界时返回特殊值分类0，它们应该排序在最前面
        return str.charAt(index) + 1;// 其他则为字符的值+1作为分类
    }
}
```

从比较的字符判断的话，高位优先排序仅仅检查能区分字符串所需的字符，而低位优先排序却对每个字符都检查最长字符串的长度的字符数量，时间复杂度上高位优先似乎要优于低位优先。

但是高位优先存在递归调用，递归深度最深为最长字符串长度，再加上本身需要的空间更多，**在字符串长度很长时递归层次非常深**，这是很可怕的。

**小数组递归的问题**可以用小数组的插入排序解决，但是**等值键问题**(很多字符串相等且长度超长时递归层次深)却难以解决。

### 字符串排序算法比较

![image-20220810150224085](数据结构.assets/字符串排序算法比较.png)

> 注意：Java并没有使用低位优先或高位优先进行字符串基数排序，因为java的标准实现中字符串比较是很快的，使得字符串的比较排序的性能不输基数排序。

## 单词查找树(待续)







## Java正则表达式使用

```java
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param str string字符串
     * @return string字符串
     */
    public String printEmail(String str) {
        Pattern pattern = Pattern.compile("[A-Za-z0-9_][A-Za-z-0-9_.-]+@[A-Za-z0-9]+(\\.[A-Za-z]{2,})+");
        Matcher matcher = pattern.matcher(str);
        ArrayList<String> result = new ArrayList<>();
        while (matcher.find()) {
            String r = matcher.group();
            result.add(r);
        }
        if (result.size() == 0) return "false";
        else {
            StringBuilder sb = new StringBuilder();
            sb.append("true");
            for (String s : result) {
                sb.append(" ").append(s);
            }
            return sb.toString();
        }
    }

    public static void main(String[] args) {
        System.out.println(new Solution().printEmail("测试样例hello-world@qq.com-cn"));
    }
}
```

上面的find()方法会从头开始查找匹配到的字符串，结合group()方法可以将其收集起来，这样一直find()+group()可以将字符串内从头到尾所有满足的字符串都收集起来。

## 经典题

### 1.字符串前缀异或

描述：一个字符串，都是小写字符，如果s的某个子串中所有字符都是偶数个，则该子串就是达标子串，求s中达标子串的最大长度。

题讲解：https://www.bilibili.com/video/BV1ce4y187g4?spm_id_from=333.999.0.0&vd_source=720927c3438ca7684ac755bff733f4ff

```java
public static int getMaxOk(String str) {
    int result = 0;
    HashMap<Integer, Integer> map = new HashMap<>();
    // status: 其中某个位置为1代表该字母是奇数个, 为0表示为偶数个
    // 两段字符串合并时：奇数+奇数=偶数，偶数+偶数=偶数，奇数+偶数=奇数，逻辑类似 异或^
    // ---> 最终的status= status1 ^ status2
    // 而题意要求的所有字符个数为偶数，其实就是26个位置都是0
    map.put(0, -1); // 0...0 (26个0表示26个字母都是偶数个)---> -1

    // 须知道0^x=x 所以当x第2次出现时，说明这两者之间的字符串状态为0，即是满足题意要求的
    int preStatus = 0;
    for (int i = 0; i < str.length(); i++) {
        char ch = str.charAt(i);
        preStatus = preStatus ^ (1 << (ch - 'a'));
        if (map.containsKey(preStatus))
            result = Math.max(result, i - map.get(preStatus));
        else map.put(preStatus, i); // 只需要将第1次出现的status及其i放入map
    }
    return result;
}
```

思想：**前缀和**，当然这里是异或。





















[^2-结点]: 一个键，两条链接
[^3-结点]: 两个键，3条链接

