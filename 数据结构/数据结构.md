# 链表

```java
// 最简单的单链表
public static class ListNode {
    public int val;
    public ListNode next;

    public ListNode(int val) {
        this.val = val;
        this.next = null;
    }

    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```



## 链表技巧

### 翻转链表

翻转链表就是将链表从头结点翻转为以尾结点作为首结点，依次连接

```java
    /** 链表翻转
     * 时间复杂度：O(N)
     * 空间复杂度：O(1)
     */
    public static ListNode reverse(ListNode head) {
        if (head == null) return null;

        ListNode pre = null, curr = head;
        while (curr != null) {
            ListNode next = curr.next;

            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;
    }
```

这个示例是将链表完全翻转，也可以用一个集合来收集所有的结点，再依次相连，不过这样空间复杂度就是O(N)了。

### 部分翻转链表

在一些情况下，并不会去完全翻转整个链表，而是翻转一部分，如每隔k个节点进行一次翻转。如[1,2,3,4,5,6,7]翻转为[3,2,1,6,5,4,7],此处按k=3进行翻转：

```java
    /*部分翻转链表，将给定的头结点到尾结点进行翻转
    返回尾结点作为翻转后的头结点，
    且翻转前的头结点需指向为null，以避免翻转成一个环了*/
    public static ListNode reverse(ListNode head, ListNode tail) {
        if (head == null) return null;

        ListNode pre = null, curr = head;
        while (tail!=pre) {
            ListNode next = curr.next;
			// 指针交换
            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;// 翻转前的尾结点，翻转后的头结点
    }
```

这里仅仅给出了一个头结点到一个尾结点的翻转，而要作为一个链表中k个节点翻转，还需处理好每个分组的连接处的连接。

### 案例：k个一组链表翻转

力扣25题，字节一面算法题(我寄于此)。

> 描述：
> 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
> k 是一个正整数，它的值小于或等于链表的长度。
> 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group
>

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {

        ListNode firstOfGroup = head, lastOfGroup,
                lastTail = null, result = null;
        while (firstOfGroup != null) {
            lastOfGroup = firstOfGroup;
            int groupLen;// 代表此组长度
            for (groupLen = 1; groupLen < k && lastOfGroup.next != null; groupLen++)
                lastOfGroup = lastOfGroup.next;

            ListNode firstOfNextGroup = lastOfGroup.next;
            // 最后一组，且不为k的话，则不翻转
            if (groupLen < k) {
                if (lastTail == null) result = head;// 说明第一组就不为k了
                else
                    lastTail.next = firstOfGroup;// 衔接上一组

                break;
            }

            ListNode headOfGroup = reversePart(firstOfGroup, lastOfGroup);// 这里翻转的可能是k个，也可能没有k个
            if (lastTail == null) // 说明是第一组
                result = headOfGroup;
            else // 接上上一组
                lastTail.next = headOfGroup;
            lastTail = firstOfGroup;

            firstOfGroup = firstOfNextGroup;
        }

        return result;
    }

    /*部分翻转，返回翻转后的头结点*/
    public ListNode reversePart(ListNode head, ListNode tail) {
        if (head == null) return null;

        ListNode pre = null, curr = head;
        while (tail != pre) {
            ListNode next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }

        return pre;// 翻转前的尾结点，翻转后的头结点
    }
}
```













# 树

## 二叉查找树

> 二叉搜索树（BST）是二叉树的一种特殊表示形式，它满足如下特性：
>
> 1. 每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值。
>
> 2. 每个节点中的值必须小于（或等于）存储在其右子树中的任何值。

对于二叉搜索树，我们可以通过`中序遍历`得到一个`递增的`有序序列。因此，中序遍历是二叉搜索树中最常用的遍历方法。

### 结点定义

对于二叉树结点的定义如下：

```java
/**
 * @author fzk
 * @date 2021-07-07 18:35
 */
// Definition for a binary tree node.
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode() {
    }

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 中序遍历

中序遍历为：先遍历左孩子，再遍历根结点，再遍历右孩子。递归实现如下：

```java
    /**
     * 中序遍历
     *
     * @param root 传入需要遍历的二叉树
     * @param list 将中序遍历的结果放入此数组中
     */
    private static void inorderTraversal(TreeNode root, List<Integer> list) {
        if (root == null)
            return;
        inorderTraversal(root.left, list);
        list.add(root.val);
        inorderTraversal(root.right, list);
    }
```

前序遍历和后续遍历只需调换那2个递归和add方法之间的顺序即可。

### 迭代器

```java
// Definition for a binary tree node.
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode() {
    }

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }

    public Iterator<TreeNode> iterator() {
        return new BSTIterator(this);
    }

    final class BSTIterator implements Iterator<TreeNode> {
        private final LinkedList<TreeNode> nodeList;// 双向链表模拟栈

        public BSTIterator(TreeNode root) {
            nodeList = new LinkedList<>();
            dfsLeft(root);
        }

        @Override
        public boolean hasNext() {
            return nodeList.size() > 0;
        }

        @Override
        public TreeNode next() {
            TreeNode root = nodeList.removeFirst();
            dfsLeft(root.right);
            return root;
        }

        void dfsLeft(TreeNode root) {
            while (root != null) {
                nodeList.addFirst(root);
                root = root.left;
            }
        }
    }
}
```

> 思想：
> 采用中序遍历的迭代器，只实现了next和hasnext方法
> 迭代器使用O(h)的内存，h为树的高度
>
> 1. 先将当前节点的所有左孩子及其左孩子压入栈，压到没有为止；
> 2. 将最后一个压入的节点弹出（栈顶元素），作为next()的返回值；
> 3. 将当前弹出节点的右节点作为当前节点，重复步骤1
>
> 这种方法的实现比较节省空间，而使用双向链表方便了快速的插入和移除栈顶元素。

### 删除结点

> 二叉搜索树的3个基本操作：查询、插入和删除。
> 查询操作非常简单；
> 插入可以很简单，也可以很复杂，如平衡二叉树。
> 删除操作就比较复杂了。

删除操作比较复杂，有很多删除的方法，这里给出整体变化最小的一种方法：

> 选择一个合适的后继结点或前驱结点来**替代**被删除结点。

根据被删除结点的情况，分为以下3类：

1. 如果目标节点**没有子节点**，我们可以直接移除该目标节点。
2. 如果目标节**只有一个子节点**，我们可以用其子节点作为替换。
3. 如果目标节点**有两个子节点**，我们需要用其中序**后继节点**或者**前驱节点**来替换，再删除该目标节点。

![bst_deletion_case_1](数据结构.assets/bst_deletion_case_1.png)

![bst_deletion_case_2](数据结构.assets/bst_deletion_case_2.png)

![bst_deletion_case_3](数据结构.assets/bst_deletion_case_3.png)

```java
   public TreeNode deleteNode(TreeNode root, int key) {
        TreeNode p=root,parent=null;// parent为被删结点的父节点
        boolean flag=true;// true代表被删除结点是parent的左孩子，false代表右孩子
        if(p==null)
            return null;
        if(p.val==key){
            if(p.left!=null){
                TreeNode pre_node=getPreNode(p.left);
                pre_node.right=p.right;
                return pre_node;
            }
            return p.right;
        }
        while(p!=null){
            if(key<p.val){
                parent=p;
                p=p.left;
                flag=true;
            }
            else if(key>p.val){
                parent=p;
                p=p.right;
                flag=false;
            }
            else{
                if(p.left==null&&p.right==null){// 第1种情况：没有子结点
                    if(flag){
                        parent.left=null;
                        return root;
                    }
                    parent.right=null;
                    return root;
                }else if(p.left==null){// 第2.1种情况：没有左孩子，有右孩子
                    if(flag){
                        parent.left=p.right;
                        return root;
                    }
                    parent.right=p.right;
                    return root;
                }
                else if(p.right==null){// 第2.2中情况：有左结点，没有右结点
                    if(flag){
                        parent.left=p.left;
                        return root;
                    }
                    parent.right=p.left;
                    return root;
                }else{
                    // 第3中情况：左右结点都有
                    // 找到其前驱结点
                    TreeNode pre_node = getPreNode(p.left);
                    pre_node.right=p.right;
                    if(flag){
                        parent.left=pre_node;
                        return root;
                    }
                    parent.right=pre_node;
                    return root;
                }
            }
        }
        return root;
    }
    public TreeNode getPreNode(TreeNode root){
        TreeNode p=root;
        if(root==null||root.right==null)
            return root;
        TreeNode parent=null;
        // 找前继结点
        while(root.right!=null){
            parent=root;
            root=root.right;
        }
        parent.right=root.left;
        root.left=p;
        return root;
    }
```

## 平衡二叉查找树

运行时间都是**对数级别**，**树高为~lgN**.需要保持二分查找树的**平衡性**。

但是，动态插入中保证树的完美平衡**代价太高**了。

**为什么需要用到高度平衡的二叉搜索树?**

> 我们已经介绍过了二叉树及其相关操作, 包括搜索、插入、删除。当分析这些操作的时间复杂度时，我们需要注意的是树的高度是十分重要的考量因素。以搜索操作为例，如果二叉搜索树的高度为 h ，则时间复杂度为 O(h) 。二叉搜索树的高度的确很重要。

> 所以，我们来讨论一下树的节点总数 N 和高度 h 之间的关系。
> 对于一个平衡二叉搜索树, h=lgN，
> 但一个普通的二叉搜索树，在最坏的情况下，它可以退化成一个链。

> 因此，具有 N 个节点的二叉搜索树的高度在 logN 到 N 区间变化。
> 也就是说，搜索操作的时间复杂度可以从 logN 变化到 N 。这是一个巨大的性能差异。

> 所以说，高度平衡的二叉搜索树对提高性能起着重要作用。

**如何实现一个高度平衡的二叉搜索树?**
有许多不同的方法可以实现。尽管这些实现方法的细节有所不同，但他们有相同的目标:

> 采用的数据结构应该满足二分查找属性和高度平衡属性。
> 采用的数据结构应该支持二叉搜索树的基本操作，包括在 **O(logN)** 时间内的搜索、插入和删除，即使在最坏的情况下也是如此。
> 常见的的高度平衡二叉树：
>
> - 红黑树
> - AVL树
> - 伸展树
> -  树堆

**高度平衡的二叉搜索树的实际应用**
高度平衡的二叉搜索树在实际中被广泛使用，因为它可以在 *O(logN)* 时间复杂度内执行所有搜索、插入和删除操作。

> 平衡二叉搜索树的概念经常运用在 Set 和 Map 中。Set 和 Map 的原理相似。

> 通常，有两种最广泛使用的集合：散列集合（**HashSet**）和 树集合（**TreeSet**）。
>
> 树集合，Java 中的 Treeset 或者 C++ 中的 set ，是由高度平衡的二叉搜索树实现的。
> 因此，搜索、插入和删除的时间复杂度都是O(logN)。
>
> 散列集合，Java 中的 HashSet 或者 C++ 中的 unordered_set ，是由哈希实现的，但是平衡二叉搜索树也起到了至关重要的作用。当存在具有相同哈希键的元素过多时，将花费 O(N) 时间复杂度来查找特定元素，其中N是具有相同哈希键的元素的数量。 通常情况下，使用高度平衡的二叉搜索树将把**时间复杂度从 O(N) 改善到 O(logN)** 。

哈希集和树集之间的本质区别在于树集中的键是有序的。



### AVL树

- 自平衡二叉查找树，又称高度平衡树。

什么是一个高度平衡的二叉搜索树?

> 树结构中的常见用语:
>
> 1. 节点的**深度** - 从树的根节点到该节点的边数
>
> 2. 节点的**高度** - 该节点和叶子之间最长路径上的边数
>
> 3. 树的高度 - 其根节点的高度

一个高度平衡的二叉搜索树（*平衡二叉搜索树*）是在插入和删除任何节点之后，可以自动保持其高度最小。也就是说，有 N 个节点的平衡二叉搜索树，它的高度是 *logN* 。并且，***每个节点的两个子树的高度不会相差超过 1***。

>为什么是 `logN` 呢?
>- 一个高度为 `h` 的二叉树 
>  2^0^ + 2^1^ +...+ 2^h-1^ +1 <= N <=2^0^ + 2^1^ +...+ 2^h^
>- 换言之，一个有 `N` 个节点，且高度为 `h` 的二叉树
    2^h^ <= N <=2^h+1^ -1.
>  h <= lgN < h+1
  - 所以： 
    h = floor(log~2~N).

#### 判断AVL

```java
class Solution {
    private boolean isBalanced;
    public boolean isBalanced(TreeNode root) {
        /*
        采用后续遍历的方式，进行每一层的高度判断
         */
        isBalanced=true;
        getHigh(root);
        return isBalanced;
    }

    public int getHigh(TreeNode root) {
        if (root == null)
            return 0;
        if (!isBalanced)
            return 0;

        int high_left = getHigh(root.left);
        int high_right = getHigh(root.right);
        if (Math.abs(high_left - high_right) > 1) {
            isBalanced = Boolean.FALSE;
        }
        return Math.max(high_left, high_right) + 1;
    }
}
```

> 判断的核心在于判断左结点和右结点的高度是否相差大于1，那么采用后续遍历递归的方式即可解决。
> 但是内存递归内存消耗较多。

#### 构建AVL

给你一个整数数组 nums ，其中元素已经按 **升序** 排列，将其转换为一棵 高度平衡 二叉搜索树。

```java
    /**
     * 传入一个数组，将其构成AVL树
     *
     * @param nums 按 严格递增 顺序排列
     * @return
     */
    public TreeNode sortedArrayToBST(int[] nums) {
        /*
        采用二分思想，左边构成左子树，右边的构成右子树，中间构成根结点
         */
        return sortedArrayToBST(nums, 0, nums.length - 1);
    }

    public TreeNode sortedArrayToBST(int[] nums, int low, int high) {
        if (low > high)
            return null;

        int mid = (low + high) >>> 1;
        TreeNode node = new TreeNode(nums[mid], null, null);//构建根结点
        node.left = sortedArrayToBST(nums, low, mid - 1);//构建左子树
        node.right = sortedArrayToBST(nums, mid + 1, high);//构建右子树
        return node;
    }
```

### 2-3查找树

为了保证查找树的平衡性，设置树中的一个结点保存多个键。
将标准二叉树的结点称为[^2-结点],而[^3-结点].

> - 2-结点，一个键，两条链接，
>   左链接指向的2-3树的键都小于该结点，
>   右链接指向的2-3树中的结点的键都大于该结点。
> - 3-结点，2个键，3条链接，
>   左链接都小于该节点，
>   中链接指向的2-3树的键都位于该结点两个键之间；
>   右链接都大于该结点。



## 二叉树技巧

```java
// 最简单的二叉树
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 二叉树序列化和反序列化

这里是按照力扣的二叉树表示方式进行序列化和反序列化，序列化和反序列化都是按照广度优先方式进行。

```java
static class Codec {
    /*leetcode 用的是广度优先方式*/
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) return "[]";

        StringBuilder builder = new StringBuilder();
        builder.append("[");

        Queue<TreeNode> queue = new LinkedList<>();
        // 保证队列中不存在null
        queue.offer(root);
        while (queue.size() != 0) {
            TreeNode poll = queue.poll();
            if (poll != nullTreeNode) {
                builder.append(poll.val).append(",");
                queue.offer(poll.left == null ? nullTreeNode : poll.left);
                queue.offer(poll.right == null ? nullTreeNode : poll.right);
            } else
                builder.append("null,");
        }
        builder.deleteCharAt(builder.length() - 1);// 删掉最后的','
        builder.append("]");

        String s = builder.substring(1, builder.length() - 1);// 准备删除末尾的null
        String[] nodes = s.split(",");
        int tailNullCount = 0;// 末尾的null的数量
        for (int i = nodes.length - 1; i > -1; i--) {
            if ("null".equals(nodes[i])) tailNullCount++;
            else break;
        }

        return builder.delete(builder.length() - 1 - 5 * tailNullCount, builder.length() - 1)
            .toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data.equals("[]")) return null;

        data = data.substring(1, data.length() - 1);
        String[] nodes = data.split(",");
        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));
        queue.offer(root);
        int index = 1;
        while (queue.size() != 0 && index < nodes.length) {
            TreeNode poll = queue.poll();
            // 左子树处理
            if (!"null".equals(nodes[index++])) {
                poll.left = new TreeNode(Integer.parseInt(nodes[index - 1]));
                queue.offer(poll.left);
            }
            // 右子树处理
            if (index >= nodes.length) break;// 先判断是否会越界
            if (!"null".equals(nodes[index++])) {
                poll.right = new TreeNode(Integer.parseInt(nodes[index - 1]));
                queue.offer(poll.right);
            }
        }
        return root;
    }

    /** 表示空树，来保证队列中不存在null */
    private static final TreeNode nullTreeNode = new TreeNode(-1);
}
```

### dfs

深度优先依赖于递归的实现，而递归又隐式依赖于栈。

```java
LinkedList<TreeNode> list = new LinkedList<>();
// 深度优先 先序遍历
public void dfs(TreeNode root) {
    if (root != null) {
        list.add(root);
        dfs(root.left);
        dfs(root.right);
    }
}
```

下面这个示例为依赖于栈实现深度优先遍历：

```java
private LinkedList<TreeNode> list = new LinkedList<>();// 存放遍历结果
private LinkedList<TreeNode> stack = new LinkedList<>();//模拟操作数栈

// 用栈实现的深度优先 先序遍历
public void dfsByStack(TreeNode root) {
    if (root != null) {
        stack.push(root);// 入栈

        while (stack.size() != 0) {
            TreeNode pop = stack.pop();// 出栈
            list.addLast(pop);
            // 这里要做到先序遍历的话，需要先入栈右子树，再入栈左子树，这样才能先遍历左子树
            if (pop.right != null) stack.push(pop.right);
            if (pop.left != null) stack.push(pop.left);
        }
    }
}
```





### bfs实现层序遍历

广度优先遍历就不能依赖递归实现了，而要借助于队列。

```java
private LinkedList<TreeNode> list = new LinkedList<>();// 存放遍历结果

// 广度优先遍历 实现的层序遍历
public void bfs(TreeNode root) {
    if (root != null) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (queue.size() != 0) {
            int num = queue.size();// 这里比较巧妙的是此时的队列长度恰好是二叉树这一层的结点数量
            while (num-- > 0) {
                TreeNode poll = queue.poll();
                list.add(poll);
                if (poll.left != null) queue.offer(poll.left);
                if (poll.right != null) queue.offer(poll.right);
            }
        }
    }
}
```



### 二叉搜索树的后继结点

力扣285，给定一棵二叉搜索树和其中的一个节点 `p` ，找到该节点在树中的中序后继。如果没有找到结点或者节点没有中序后继，请返回 `null` 

思路：二叉搜索树按中序遍历将是有序的，后继结点即大于其的第一个结点。按照中序遍历顺序，结点将会按照升序访问，那么在访问到p之后，下一个必定是访问其后继结点。

```java
class Solution {
    private boolean isFound = false;
    private TreeNode midOrderNext = null;

    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        if (root == null) return null;

        dfs(root, p);
        return midOrderNext;
    }

    private void dfs(TreeNode root, TreeNode p) {
        if (root == null) return;
        if (isFound&&midOrderNext!=null) return;//已经找到则不再深入遍历

        dfs(root.left, p);// 遍历左子树
        if (isFound && midOrderNext == null) midOrderNext = root;

        if (root.val == p.val) isFound = true;
        dfs(root.right, p);// 遍历右子树
    }
}
```

### 二叉树的迭代器

借助于单链表实现：关键在于实现next()和hasNext()方法

```java
// 二叉树的迭代器
public static class BSTIterator {
    //中序遍历二叉树迭代器
    BSTIterator.ListNode head;
    BSTIterator.ListNode tail;

    public BSTIterator(TreeNode root) {
        // 链表头结点
        head = new BSTIterator.ListNode(Integer.MIN_VALUE, null);
        tail = head;
        dfs(root);
    }

    private void dfs(TreeNode root) {
        if (root != null) {
            dfs(root.left);
            tail.next = new BSTIterator.ListNode(root.val, null);
            tail = tail.next;
            dfs(root.right);
        }
    }

    public int next() {// 会使得指针右移
        head = head.next;
        return head.val;
    }

    public boolean hasNext() {
        return head.next != null;
    }

    private static class ListNode {
        public int val;
        public BSTIterator.ListNode next;

        public ListNode(int val, BSTIterator.ListNode next) {
            this.val = val;
            this.next = next;
        }
    }
}
```





# 数学

## 质数

质数即除了1和它本身外没有其他因数的自然数。

力扣204题，统计小于n的所有质数个数，0<=n<=5*10<sup>6</sup>

### 暴力枚举

所谓枚举，就是从2开始一个个数，暴力解决问题。

```java
class Solution {
    public int countPrimes(int n) {
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            ans += isPrime(i) ? 1 : 0;
        }
        return ans;
    }

    public boolean isPrime(int x) {
        if(x<=1) return false;// 边界处理
        if(x&1==0) return false;// 先排除偶数
        for (int i = 3; i * i <= x; ++i) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```

时间复杂度：O(N*N<sup>1/2</sup>)；空间复杂度：O(1)

### 埃氏筛

该算法由希腊数学家厄拉多塞（EratosthenesEratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛
如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x… 一定不是质数，那么可以建立一个标记数组，对每个质数，标记其倍数为合数，这样之后遇到的只要没被标记过，就一定是质数(因为它不是任何小于它的数的倍数)。
在标记的时候，也不必从2x开始标记，因为2x一定被2这个质数标记过了，可以从x*x开始标记。

```java
public int countPrimes(int n) {
    if (n <= 1) return 0;
    // 埃氏筛
    boolean[] isPrime = new boolean[n + 1];
    Arrays.fill(isPrime, true);
    int count = 0;// 质数个数

    for (int i = 2; i < n; i++) {
        if (isPrime[i]) {// 没有被标记为false
            count++;
            // 开始埃氏筛标记
            for (long j = ((long) i * i); j < n; j += i)
                isPrime[(int) j] = false;
        }
    }
    return count;
}
```

时间复杂度：O(N lg(lgN))；空间复杂度：O(N)



# concurrent

此节记录一些自己实现的并发集合，如阻塞队列

## 阻塞队列

用数组实现的阻塞队列有容量上限，在队列为空或者队列满了，消费者或生产者分别需要等待.

借助于可重入锁及其Condition实现

```java
/**
 * 借助数组、可重入锁、Condition实现的阻塞队列
 *
 * @author fzk
 * @date 2022-01-03 22:14
 */
public class MyBlockQueue<T> {
    private final Object[] items;
    private int addIndex, removeIndex, count;
    private final ReentrantLock lock;
    private final Condition notEmpty;
    private final Condition notFull;

    public MyBlockQueue(int capacity) {
        items = new Object[capacity];
        count = 0;
        addIndex = 0;
        removeIndex = 0;
        lock = new ReentrantLock();
        notEmpty = lock.newCondition();
        notFull = lock.newCondition();
    }

    // 添加一个元素，如果队列慢，则进入等待状态
    public void add(T t) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)// while防止虚假唤醒
                notFull.await();// 等非满信号

            items[addIndex] = t;
            if (++addIndex == items.length) addIndex = 0;
            ++count;
            notEmpty.signal();// 放一个非空信号
        } finally {
            lock.unlock();
        }
    }

    // 移除并返回队首元素，如果数组为空，则等待
    public T remove() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)// while防止虚假唤醒
                notEmpty.await();// 等待非空信号

            Object t = items[removeIndex];
            items[removeIndex] = null;
            if (++removeIndex == items.length) removeIndex = 0;
            count--;
            notFull.signal();// 放非满信号
            return (T) t;
        } finally {
            lock.unlock();
        }
    }
}
```







## 安全哈希映射

此处的安全哈希映射效率并不高，远远不如ConcurrentHashMap的效率，但是比用`synchronized`效率高点。

借助于读写锁，在读多写少的情况下，效率还是可以的。

```java
/**
 * 借助读写锁实现的HashMap安全映射
 *
 * @author fzk
 * @date 2022-01-03 21:31
 */
public class MySafeHashMap<K, V> {
    private final HashMap<K, V> map;
    private final ReentrantReadWriteLock readWriteLock;// 读写锁
    private final ReentrantReadWriteLock.ReadLock readLock;// 读锁
    private final ReentrantReadWriteLock.WriteLock writeLock; // 写锁

    public MySafeHashMap(int capacity) {
        map = new HashMap<>(capacity);
        readWriteLock = new ReentrantReadWriteLock();// 读写锁
        readLock = readWriteLock.readLock();
        writeLock = readWriteLock.writeLock();
    }

    public V get(K key) {
        readLock.lock();// 锁定操作不能放入try块，避免出现try中发生的获取锁(自定义锁)时发生异常导致锁无故释放
        try {
            return map.get(key);
        } finally {
            readLock.unlock();
        }
    }

    /*返回null或者旧的值*/
    public V put(K key, V value) {
        LockSupport.park(this);
        writeLock.lock();// 锁定操作不能放入try块，避免出现try中发生的获取锁(自定义锁)时发生异常导致锁无故释放
        try {
            return map.put(key, value);
        } finally {
            writeLock.unlock();
        }
    }

    // 清空集合
    public void clear() {
        writeLock.lock();// 锁定操作不能放入try块，避免出现try中发生的获取锁(自定义锁)时发生异常导致锁无故释放
        try {
            map.clear();
        } finally {
            writeLock.unlock();
        }
    }
}
```





# 比较排序算法

>特点：1.没有任何基于比较的算法能够保证使用少于 lg(N!)~NlgN 次比较将长度为N的数组排序。证明过程在算法第四版P177。

## 前言

1.笔记目前记录了比较排序算法(经典排序算法)，对于计数排序、桶排序以及基数排序算法在这里留有坑位，期末考完后再填坑。
2.笔记大部分知识点来自于《算法》第四版，也有参考博客。
3.在刷题中也会陆陆续续添加一些知识点。

![排序算法比较](数据结构.assets/排序算法比较.jpg)



## 0. 排序算法模板

```java
/**
 * @author fzkstart
 * @create 2020-12-06 16:05
 * 排序算法类的模板
 */
public class Example {
    public static void sort(Comparable[] a){
       //各个排序算法的具体实现
    }

    private static boolean less(Comparable v,Comparable w){
        return v.compareTo(w)<0;
    }

    private static void exch(Comparable[] a,int i,int j){
        Comparable t=a[i];
        a[i]=a[j];
        a[j]=t;
    }

    public static void show(Comparable []a){
        //在一行中打印数组
        for(int i=0;i<a.length;i++)
            System.out.print(a[i]+" ");
        System.out.println();
    }

    public static boolean isSorted(Comparable []a){
        //测试数组是否有序
        for(int i=1;i<a.length;i++)
            if(less(a[i],a[i-1]))
                return false;
        return true;
    }
}
```



## 1. 初级排序

### 1.1 选择排序

- 思想：首先找到数组中最小的元素，将它与数组第一个元素交换位置。重复操作，直至有序。不断选择剩余元素中最小者，故称选择排序。

- 算法实现：

  ```java
  /**
  * 1. 初级排序算法
  * 1.1 选择排序
  * 特点：1.运行时间与输入元素的有序程度无关，排序时间一样长;
  *      2.数据移动是最少的;
  *      3.不稳定的排序方法;
  *      4.复杂度分析：
  *          时间复杂度：n次交换，n*(n-1)/2次比较；O(N^2)
  *          空间复杂度：O(1)
  *
  * @author fzkstart
  * @create 2020-12-06 16:05
  */
  public class Selection {
      public static void sort(Comparable[] a){
          //默认升序排序
          int n=a.length;
          for(int i=0;i<n;i++){
              int minIndex=i;  //  最小元素的索引
              for(int j=i+1;j<n;j++)
                  if(less(a[j],a[minIndex]))
                      minIndex=j;
              exch(a,i,minIndex);
          }
      }
  }
  ```

- 特点：

  - 1.运行时间和输入无关；
  - 2.数据移动是最少的（N次交换，线性关系，其他的任何算法都不具备）；
  - 3.不稳定。

- 复杂度：

  - 时间复杂度：O(N^2)；需要n*(n-1)/2次比较和n次交换。
  - 空间复杂度：O(1)，原地排序

- 分析：选择排序过于简单，而且运行时间固定，一般都不用这个。

### 1.2 插入排序

- 思想：将一个元素插入到已经有序的数组中的适当位置，为了给插入元素挪位置，将其余元素都右移。插入元素索引左边的元素都是有序的，但不一定这就是它们的最终位置。当插入索引来到最右边的时候，数组就有序了。

- 算法实现：

  ```java
  /**
  * 1.初级排序算法
  * 1.2 插入排序
  * 特点：1.所需的时间取决于数组中元素的初始顺序，时间上：部分有序<随机数组<逆序数组
  *      2.复杂度分析：
  *      时间复杂度： 最坏情况：1/2N^2次比较1/2N^2次移动；O(N^2)
  *                  最好情况：N-1次比较和0次移动; O(N)
  *                  平均情况：1/4N^2次比较和1/4N^2移动; O(N^2)
  *      空间复杂度：O(1)
  * @author fzkstart
  * @create 2020-12-06 16:57
  */
  public class Insertion {
      public static void sort(Comparable[] a){
          //正向插入排序算法，升序，从左向右，稳定
          int n=a.length;
          Comparable temp=null;
          int j=0;
          for(int i=1;i<n;i++){
              temp=a[i];
              //将 a[i] 插入到a[i-1]、a[i-2]...中
              /* 不使用exch方法：
              for(int j=i;j>0&&less(a[j],a[j-1]);j--)
              exch(a,j,j-1); */
              //改为将较大的元素右移而不是交换，访问数组次数可以减半
              for(j=i;j>0&&less(temp,a[j-1]);j--){
                  a[j]=a[j-1];
              }
              a[j]=temp;
          }
      }
      public static void sort(Comparable[] a,int lo,int hi){
          //正向插入排序算法，升序，从左向右，稳定
          Comparable temp=null;
          int j=0;
          for(int i=lo+1;i<=hi;i++){
              temp=a[i];
              for(j=i;j>lo&&less(temp,a[j-1]);j--){
                  a[j]=a[j-1];
              }
              a[j]=temp;
          }
      }
      public static void sortReverseStable(Comparable[] a){
          //反向插入排序算法，降序，从右向左,稳定
          int n=a.length;
          Comparable temp=null;
          int j=0;
          for(int i=n-2;i>=0;i--){
              temp=a[i];
              for(j=i;j<n-1&&less(temp,a[j+1]);j++){
                  a[j]=a[j+1];
              }
              a[j]=temp;
          }
      }
      public static void sortReverseUnStable(Comparable[] a){
          //反向插入排序算法，降序，从右向左，不稳定
          int n=a.length;
          Comparable temp=null;
          int j=0;
          for(int i=n-2;i>=0;i--){
              temp=a[i];
              for(j=i;j<n-1&&temp.compareTo(a[j+1])<=0;j++){
                  a[j]=a[j+1];
              }
              a[j]=temp;
          }
      }
  }
  ```

- 特点：

  - 1.所需的时间取决于数组中元素的初始顺序，时间上：部分有序<随机数组<逆序数组
  - 2.当倒置的数量很少的时候，插入排序可能会是最快的比较排序。
  - 3.稳定的（也可以改为不稳定的）

- 复杂度：

  -  时间复杂度： 
     - 最坏情况：1/2N^2 次比较1/2N^2 次移动；O(N^2)
     - 最好情况：N-1次比较和0次移动; O(N)
     - 平均情况：1/4N^2 次比较和1/4N^2移动; O(N^2)
  -  空间复杂度：O(1)，原地排序

- 分析：插入排序的用法比选择排序更广，而且插入排序改动一下可以满足许多的题目要求。


### 1.3 希尔排序

- 思想：对于大规模乱序的数组，插入排序很慢，因为它只会交换相邻的元素。为了加快速度，简单改进插入排序，交换不相邻的元素对数组局部排序，最终用插入排序对局部有序数组进行排序。

- 算法实现：

  ```java
  /**
  * 1.初级排序算法：
  * 1.3 希尔排序
  * 特点：1.是对插入排序的简单改进，类似于插入排序，但是增量为h，
  *      即数组中任意间隔为h的元素都是有序的，即h有序数组。
  *      2.希尔排序比插入排序和选择排序更高效，并且数组越大，优势越大；
  *      因为它权衡了子数组的规模和有序性。
  *      3.增量h的递增序列会影响算法性能，但在实际应用中区别不明显。
  *      4.复杂度分析：希尔排序难以准确描述其性能
  *              此例子中使用的递增序列在最坏情况下，比较次数和N^(3/2)成正比。
  *          时间复杂度：O(N^3/2)
  *          空间复杂度：O(1)
  * @author fzkstart
  * @create 2020-12-08 19:15
  */
  public class Shell {
      public static void sort(Comparable[] a){
          //默认升序排序，Shell排序算法
          int n=a.length;
          int h=1;
          //h为间隔,此处选择较为简单的递增序列
          while(h<n/3)
              h=h*3+1;
          Comparable temp=null;
          int j=0;
          while(h>=1){
              for(int i=h;i<n;i++){
                  temp=a[i];
                  for(j=i;j>=h&&less(temp,a[j-h]);j-=h){
                      a[j]=a[j-h];
                  }
                  a[j]=temp;
              }
              h=h/3;
          }
      }
  ```

- 特点：

  - 1.是对插入排序的简单改进，类似于插入排序，但是增量为h，      
    即数组中任意间隔为h的元素都是有序的，即h有序数组。
  - 2.希尔排序比插入排序和选择排序更高效，并且数组越大，优势越大；     
    因为它权衡了子数组的规模和有序性。
  - 3.增量h的递增序列会影响算法性能，但在实际应用中区别不明显。

- 复杂度：希尔排序难以准确描述其性能

  - 此例子中使用的递增序列在最坏情况下，比较次数和N^(3/2)成正比。         
  - 时间复杂度：O(N^3/2)          
  - 空间复杂度：O(1)，原地排序

- 分析：希尔排序没有插入排序用处广，毕竟就单排序而言，希尔比插入快，但还有更快的。


## 2. 归并排序

- 思想：一种递归排序算法。将数组递归地分两半进行排序，然后将结果归并起来。最吸引人的性质是能保证任意数组排序所需时间和NlogN成正比，但主要缺点是需要额外空间也和N成正比。

### 2.0 原地归并的抽象方法

```java
/**
    * 原地递归的抽象方法
    * @param a
    * @param lo
    * @param mid
    * @param hi
    */
public static void merge(Comparable[] a,Comparable[] aux,int lo,int mid,int hi){
    // 将a[lo..mid]和a[mid+1..hi]归并
    int i=lo,j=mid+1;
    for(int k=lo;k<=hi;k++)
        aux[k]=a[k]; // 将a[lo..hi]复制到aux[lo..hi]

    for(int k=lo;k<=hi;k++){
        if(i>mid) a[k]=aux[j++];
        else if(j>hi) a[k]=aux[i++];
        else if(less(aux[j],aux[i])) a[k]=aux[j++];
        else a[k]=aux[i++];
    }
}
```

### 2.1 自顶向下的归并排序

- 思想：递归归并，分治思想一种典型应用。这段递归代码是归纳证明算法能够正确排序的基础：如果它能将两个子数组排序，它就能通过归并两个子数组将整个数组排序。

- 算法实现：

  ```java
  /**
  * 2. 归并排序
  * 2.1 自顶向下的归并排序
  * 特点：1.递归归并，体现分治思想，化整为零，递归解决
  *      2.稳定性分析：具有稳定性
  *      3.复杂度分析：
  *          时间复杂度：O(NlogN);
  *                      需要1/2NlgN~NlgN次比较，最多需要访问数组6NlgN次；
  *                      归并树状图层数为lgN，每层归并最多访问6N次数组，
  *                      2N用于复制，2N用于移动，2N用于比较；
  *          空间复杂度：O(N)
  *      4.性能优化：递归会使得小规模问题中方法的调用过于频繁，
  *      可以尝试用插入排序处理小规模数组(如n<15)，一般能将归并排序的
  *      运行时间缩短10%~15%。
  * @author fzkstart
  * @create 2020-12-09 10:06
  */
  public class Merge {
      /**
      * 自顶向下的归并排序
      * 基于原地归并的抽象来实现
      * @param a
      */
      public static void sort(Comparable[]a){
          // 归并所需的辅助数组
          Comparable[] aux=new Comparable[a.length]; // 一次性分配空间
          sort(a,aux,0,a.length-1);
      }
      private static void sort(Comparable[]a,Comparable[] aux,int lo,int hi){
          // 将数组a[lo..hi]排序
          if(hi<=lo) return;
          int mid=lo+(hi-lo)/2;
          sort(a,aux,lo,mid);             // 将左半边排序
          sort(a,aux,mid+1,hi);       // 将右半边排序
          merge(a,aux,lo,mid,hi);        // 归并结果
      }
  }
  ```

- 特点：

  - 1.递归归并，体现分治思想，化整为零，递归解决
  - 2.稳定性分析：具有稳定性

- 复杂度：

  - 时间复杂度：O(NlogN);
    - 需要1/2NlgN~NlgN次比较，最多需要访问数组6NlgN次；
    - 归并树状图层数为lgN，每层归并最多访问6N次数组，2N用于复制，2N用于移动，2N用于比较；
  - 空间复杂度：O(N)

- 分析：

![归并排序树状图](数据结构.assets/归并排序树状图.jpg)

- 性能优化：递归会使得小规模问题中方法的调用过于频繁，可以尝试用插入排序处理小规模数组(如n<15)，一般能将归并排序的运行时间缩短10%~15%。

### 2.2 自底向上的归并排序

- 思想：
  - 1. 将一个大问题分割为小问题分别解决，然后用所有小问题的答案来解决整个大问题。
  - 2. 先归并小数组，然后成对归并得到的子数组，直至将整个数组归并在一起。
  - 3. 首先是两两归并，然后是四四归并、、、
- 算法实现：

```java
/**
 * 2.归并排序
 * 2.2 自底向上的归并排序
 * 特点：1.循序渐进解决
 *      2.其他特点同自顶向下的归并排序
 *      3.当数组长度为2的幂时，两者的比较次数和访问次数同，其他情况次序会有所不同
 *      4.自底向上归并排序比较适合用于链表
 * @author fzkstart
 * @create 2020-12-09 11:58
 */
public class MergeBU {
    /**
     * 自顶向下的归并排序
     * 基于原地归并的抽象来实现
     * @param a
     */
    public static void sort(Comparable[]a){
        int N=a.length; // 进行lgN次两两归并
        Comparable []aux=new Comparable[N]; // 归并所需的辅助数组
        for(int sz=1;sz<N;sz+=sz)  // sz是子数组的大小
            for(int lo=0;lo<N-sz;lo+=sz+sz) // lo:子数组索引
                merge(a,aux,lo,lo+sz-1,Math.min(lo+sz+sz-1,N-1));
    }
```

- 特点：
  - 1.循序渐进解决
  - 2.其他特点同自顶向下的归并排序
  - 3.当数组长度为2的幂时，两者的比较次数和访问次数同，其他情况次序会有所不同
  - 4.自底向上归并排序比较适合用于链表
- 复杂度：
  - 时间复杂度：O(NlogN);
  - 空间复杂度：O(N)
- 分析：自底向上归并排序适合于链表，？？？
  - 两种方式都可以实现任何分治类算法。
  - Merge.sort()化整为零，递归解决。
  - MergeBU.sort()循序渐进解决问题。

***

## 3. 快速排序

- 思想：一种分治的排序算法。
- 特点

>1.应用最广泛的排序算法，原因是它实现简单、适用于各种不同的输入数据且在一般应用中比其他排序算法快得多。

>2.原地排序且时间复杂度O(NlgN)。快速排序的内循环比大多数排序算法都要短小，意味着它无论是理论上还是实际中都要更快。

>3.主要缺点是非常脆弱。使用不小心可能性格将会下降到平方级别。

>4.一种偏爱随机性的算法。

### 3.1 二分法快速排序

- 思想：选取哨兵元素，将数组分为两半，左边都是不大于哨兵的，右边都是不小于哨兵的，递归切分，当两个子数组都有序的时候，则数组有序。
- 算法实现：

```java
/**
 * 3.快速排序
 * 3.1基本的快速排序(二分法)
 * 思想：该方法的关键在于切分：对于某个j，a[j]已经排定
 *      a[lo]到a[j-1]中所有元素都不大于a[j],a[j+1]到a[hi]所有元素都不小于a[j]
 * 特点：1.缺点：在切分不平衡时，会变得极为低效；
 *      2.复杂度分析：
 *          时间复杂度：O(NlgN)，平均~2NlnN次比较，~1/3NlnN次交换；
 *                      最多~N^2次比较，随机打乱数组可以预防这种情况；
 *                      移动次数相对于归并排序更少；
 *          空间复杂度：O(lgN)，原地排序（只需要一个很小的辅助栈）
 *       3.算法改进：1.对于小数组，插入排序更快，因为递归调用sort()影响速度；
 *                2.第二个方法是使用子数组的一部分元素的中位数切分数组，代价是需要计算中位数
 * @author fzkstart
 * @create 2020-12-09 16:42
 */
public class Quick {
    public static int M=5;//参数M是切换到插入排序的小数组长度，5~15都可以

    public static void sort(Comparable[] a){
        sort(a,0,a.length-1);
    }

    private static void sort(Comparable[] a,int lo,int hi){
        if(hi<=lo+M){//切换到小数组的插入排序
            Insertion.sort(a,lo,hi);
            return;
        }
        int j=partition1(a,lo,hi);   //切分
        sort(a,lo,j-1);         //将左半部分a[lo..j-1]排序
        sort(a,j+1,hi);         //将右半部分a[j+1..hi]排序
    }

    /**
     * 快速排序的切分
     * @param a
     * @param lo
     * @param hi
     * @return
     */
    private static int partition(Comparable[] a,int lo,int hi){
        //将数组切分为a[lo..i-1],a[i],a[i+1..hi]
        int i=lo,j=hi+1;    //左右扫描指针
        Comparable  v=a[lo];//切分元素
        while(true){//扫描左右，检查扫描是否结束并交换元素
            while(less(a[++i],v)) if(i==hi) break;
            while(less(v,a[--j])) continue;
            if(i>=j) break;
            //这里可能会将一些等值的元素交换位置，
            // 当有大量的重复元素时，使用三向切分快速排序效率更高
            exch(a,i,j);
        }
        exch(a,lo,j);   //将v=a[j]放入正确的位置
        return j;       //a[lo..j-1]<=a[j]<=a[j+1..hi]达成
    }
    private static int partition1(Comparable[] a,int lo,int hi){
        //将数组切分为a[lo..i-1],a[i],a[i+1..hi]
        int pivot=(int)(lo+Math.random()*(hi-lo+1));//切分元素的索引
        int i=lo-1,j=hi+1;    //左右扫描指针
        Comparable  v=a[lo];//切分元素
        while(true){//扫描左右，检查扫描是否结束并交换元素
            while(less(a[++i],v)) continue;
            while(less(v,a[--j])) continue;
            if(i>=j) break;
            //这里可能会将一些等值的元素交换位置，
            // 当有大量的重复元素时，使用三向切分快速排序效率更高
            exch(a,i,j);
        }
        exch(a,pivot,j);   //将v=a[j]放入正确的位置
        return j;       //a[lo..j-1]<=a[j]<=a[j+1..hi]达成
    }
}
```

- 特点： 

  >1.内循环短小；内循环会用一个递增的索引将数组元素和切分元素比较，不仅简洁，而且迅速。
  >2.相比于归并排序，比较次数多39%，但是移动数据次数更少。因而快速排序一般更快。
  >3.排序效率依赖切分数组的效果。
  >4.不稳定。

- 复杂度： 见代码

- 分析：

  >1.快速排序核心在于切分，切分选择的哨兵元素又及其依赖随机性，有两种方式保持随机性，一种是随机打乱数组，另一种是随机选择一个切分元素。

  >2.当有大量的重复元素情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的改进潜力，将当前实现的线性对数级性能提高到线性级别。

### 3.2 三向切分快速排序

- 思想：在有很多重复元素的时候，快速排序会产生很多不必要的交换元素，因而产生了三向切分。但是在重复元素不多的时候，它又比标准二分法多使用了很多次交换。将数组切分为三部分，分别对应小于、等于、大于切分元素。
- 算法实现：

```java
/**
 * 3.快速排序
 * 3.2 三向切分快速排序
 * 思想：当数组中存在大量重复元素，快速排序性能尚可，但还有巨大改进空间。
 *      将数组切分为三部分，分别对应小于、等于、大于切分元素。
 * 特点：1.对于存在大量重复元素的数组，归并排序时间复杂度是线性对数的，而三向切分则是线性的；
 *      2.三向切分快速排序对重复元素的适应性，使得其成为排序库函数的最佳算法选择；
 *      3.缺点：在数组中重复元素不多的情况下，它比标准二分法多了很多次交换。
 * @author fzkstart
 * @create 2020-12-09 22:28
 */
public class Quick3way {
    public static int M=5;//参数M是切换到插入排序的小数组长度，5~15都可以

    public static void sort(Comparable[] a){
        sort(a,0,a.length-1);
    }

    private static void sort(Comparable[] a,int lo,int hi){
        if(hi<=lo+M){//切换到小数组的插入排序
            Insertion.sort(a,lo,hi);
            return;
        }
//        if(hi<=lo) return;
        int lt=lo,i=lo+1,gt=hi;
        Comparable v=a[lo];
        while(i<=gt){
            int cmp=a[i].compareTo(v);
            if(cmp<0)       exch(a,lt++,i++);
            else if(cmp>0)  exch(a,i,gt--);
            else            i++;
        }   //  现在a[lo..lt-1]<v=a[lt..gt]<a[gt+1..hi]成立
        sort(a,lo,lt-1);         //将左半部分a[lo..lt-1]排序
        sort(a,gt+1,hi);         //将右半部分a[gt+1..hi]排序
    }
}
```

- 分析：
  1.排序库函数最佳选择；
  2.重复元素不多时，性能不如二分法快速排序。


## 4. 堆排序

>通过插入一列元素然后一个个地删除最小的元素，我们可以用优先队列实现排序算法。

>堆排序来自于基于堆的优先队列的实现。

### 4.1 基于最大堆的堆排序

- 思想：将最大堆的最大元素a[0]和a[n-1]交换,最大元素到达自己的位置，此时将堆长-1，再重新有序化堆，即可一步步将最大元素交换到自己的位置。重复操作直至堆空。利用了最大堆保存最大元素性质，每次将最大元素挪到后面，实现排序。
- 步骤：

>阶段1：构造最大堆，从最后一个非叶子节点开始下沉修复堆，循环至索引为0。只需要扫描一半元素即可，因为可以跳过大小为1的堆。（相当于堆合并）

>阶段2：下沉排序；将堆中最大元素删除，然后放入堆缩小后数组空出的位置。类似选择排序每次选择最大元素。

- 代码实现：

```java
/**
 * 4.堆排序
 * 思想：用数组模拟堆的完全二叉树。从右向左用下沉方法sink()构造子堆，
 * 如果一个节点左右子树已经是堆，再调用sink()，可以将它们变成一个堆。
 * 将堆的最大元素a[0]和a[n-1]交换,此时堆长-1，再重新有序化堆。重复操作直至堆空。
 * 特点：1.分两步：构造堆；下沉排序
 *      2.不稳定
 *      3.复杂度：
 *          时间复杂度：O(NlogN); 最多2NlgN+2N次比较和一半次数的交换；
 *                     2N来自于堆构造；每次下沉最多2NlgN比较
 *          空间复杂度：O(1),原地排序。
 *      4.唯一能够同时最优利用空间和时间的方法；在空间很紧张时很流行；
 *      5.缺点：现代系统很多应用很少使用它，因为它无法利用缓存。缓存未命中次数远高于相邻元素比较法，
 *       如快速排序、归并排序，甚至是希尔排序。
 * @author fzkstart
 * @create 2020-12-11 12:19
 */
public class Heap {
    public static void HeapSort(Comparable[] a){
        int n=a.length; // n为数组长度
        //  左子树和右子树分别是2k+1和2k+2

        //1.阶段一：for循环构造堆,此时a[0]为最大元素，最大堆
        for(int k=n/2-1;k>=0;k--)
            sink(a,k,n);
        //2.阶段二：下沉排序
        while(n>1){
            //while循环将a[0]和a[n-1]交换并修复堆（此时n--，堆长减1）,
            //通过sink()重新选择最大元素到a[0]
            exch(a,0,--n);
            sink(a,0,n);
        }
    }
    //下沉
    private static void sink(Comparable[] a,int k,int n){
        while(2*k+1<n){    //存在左子树
            int maxIndex = k*2+1; //指向左子树
            //如果有右子树，且右子树大于左子树，则将最大指针指向右子树
            if (maxIndex+1<n&&less(a[maxIndex],a[maxIndex+1]))
                maxIndex ++;
            //父节点是最大值时，退出循环
            if(!less(a[k],a[maxIndex])) break;
            //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。
            exch(a,k,maxIndex);
            k=maxIndex;
        }
    }
```

- 特点：见代码
- 复杂度： 见代码
- 分析：此处构造的最大堆，然后将堆顶与堆尾交换，堆顶优先级下降，使用下沉修复堆（堆的有序化）。
  最小堆的构造只需改动一下sink()即可。

### 4.2 下沉和上浮

```java
/**
 * 下沉，最小堆
 *
 * @param arr 堆
 * @param k   需要下沉的堆顶索引，其左子树为2k+1，右子树为2k+2
 * @param n   堆长度
 */
public static void sink(int[] arr, int k, int n) {
    int leftIndex, rightIndex, minIndex;
    while ((leftIndex = (k << 1) + 1) < n) {// 即存在左子树
        minIndex = k;
        if (arr[leftIndex] < arr[k]) minIndex = leftIndex;

        // 如果存在右子树
        if ((rightIndex = (k << 1) + 2) < n && arr[rightIndex] < arr[minIndex])
            minIndex = rightIndex;

        // 将最小的移到父节点k处
        if (k != minIndex) {
            int tmp = arr[k];
            arr[k] = arr[minIndex];
            arr[minIndex] = tmp;
            k = minIndex;// 循环下沉
        } else break;// 父节点是最小结点，则下沉结束
    }
}

/**
 * 上浮，最小堆
 *
 * @param arr 堆
 * @param k   需要上浮的索引，必须是刚加入堆的最后一个结点
 */
public static void floatUp(int[] arr, int k) {
    int parentIndex;// 父节点索引为(k-1)/2
    while ((parentIndex = ((k - 1) >> 1)) >= 0) {
        if (arr[k] < arr[parentIndex]) {
            int tmp = arr[parentIndex];
            arr[parentIndex] = arr[k];
            arr[k] = tmp;
            k = parentIndex;// 循环上浮
        } else break;// 上浮完成
    }
}
```



### 4.3 基于最小堆的堆排序

```java
/**
 * 基于最小堆的排序，这里会比最大堆排序稍微麻烦一点，最大堆排序看笔记
 * 每次只能选出堆顶最小的一个元素，将其和堆尾进行交换，再缩小堆长度，从堆顶进行下沉操作
 * 此时得到的是降序的，可以翻转为升序的
 */
public static void heapSort(int[] arr) {
    int n = arr.length;// n代表堆长度
    // 1.以下沉构建最小堆
    for (int k = (n >> 1) - 1; k >= 0; k--)
        sink(arr, k, n);

    // 2.while循环将a[0]和a[n-1]交换并修复堆（此时n--，堆长减1）,通过sink()重新选择最小元素到a[0]
    while (n > 1) {
        int tmp = arr[0];
        arr[0] = arr[n - 1];
        arr[n - 1] = tmp;
        // 堆缩容并下沉操作
        sink(arr, 0, --n);
    }
    
    // 3.将降序数组翻转为升序(如果是最大堆，则不需要此步骤)
    for (int left = 0, right = arr.length - 1; left < right; left++, right--) {
        int tmp = arr[left];
        arr[left] = arr[right];
        arr[right] = tmp;
    }
}
```





## 小结

![比较排序小结](数据结构.assets/比较排序小结.jpg)

1. 快速排序是最快的通用排序算法

   >内循环指令少，能利用缓存（总是顺序的访问数据）
   >但如果稳定性很重要而空间不是问题，归并排序可能最好。

2. 稳定的只有插入和归并，其中插入也是可以改为不稳定的。

3. Java系统库的排序算法：
   **java.util.Arrays.sort()**，它实际上是一系列的排序方法：

    - 每种原始数据类型都有一个不同的排序方法；
    - 一个适用于所有实现了Comparable接口的数据类型的排序方法；

 - 一个适用于所有实现了比较器接口Comparator的数据类型的排序方法；

   对原始数据使用**三向切分快速排序**，
   对引用数据类型使用**归并排序**。

   >这实际上也暗示着用速度和空间(对于原始数据类型)来换取稳定性(对引用数据类型)。

4. 自己使用排序算法时候，尽量就不去调用库函数，在一般情况下使用Quick.sort()，稳定性比空间更重要的时候用Merge.sort()。
5. 实际问题解决：目前在刷题中，其实对于排序本身的要求并不高，更多是在要求用排序算法的思想来解决问题。学习排序算法，应该更关注于它本身的实现所体现的思想，而不是真的为了排序。





































[^2-结点]: 一个键，两条链接
[^3-结点]: 两个键，3条链接

